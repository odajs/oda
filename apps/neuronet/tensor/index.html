<meta charset="UTF-8">
<title>TENSOR</title>
<oda-tensor></oda-tensor>
<script type="module">
    import '../../../oda.js';
    import Tensor from  './tensor.js';
    ODA({is: 'oda-tensor', imports: '@oda/app-layout, @oda/scheme-layout', extends: 'oda-app-layout',
        template:`
            <div vertical slot="left-panel" opened>
               <textarea flex ::value="program"></textarea>
               <oda-button no-flex @tap="build"  style="text-align: center; padding: 8px;">BUILD</oda-button>
            </div>
            <oda-scheme-layout :items slot="main" ></oda-scheme-layout>
        `,
        program:{
            $save: true,
            $def: ''
        },
        build(){
            const func = new Function('tensor', this.program);
            this.outputs = [func(tensor)];
        },
        outputs: [],
        toIcon(){
            return ''
        },
        get items() {
            let rez = { data:[], xMax:0, yMax:0, m:{}, n: new Map() }
            let addBl = (tensor, y) => {
                if (rez.n.get(tensor) === undefined) {
                    rez.m[y]??=0
                    rez.m[y]++
                    rez.n.set(tensor,rez.data.length)
                    let bind = tensor.children.map( (v,i) => { return { block: v, top: 0 } })
                    let obj = {
                        is: "oda-net-node",
                        x: rez.m[y],
                        y,
                        tensor,
                        pins: {
                            top: [{}],
                            bottom: (bind.length)? [{ bind }]:[]
                        }
                    }
                    rez.xMax = Math.max(rez.xMax,obj.x)
                    rez.yMax = Math.max(rez.yMax,obj.y)
                    rez.data.push(obj)
                    tensor.children.forEach((c, i) => addBl(c, obj.y+1));
                }
            }
            this.outputs.forEach( out => addBl(out,0))
            let [dX, dY] = [100, 150]
            rez.data.forEach(bl => {
                bl.x = ((2 * bl.x - 1) / rez.m[bl.y] ) * rez.xMax * dX
                if (bl.tensor.t === 'input')
                    bl.y++
                bl.y = (bl.y + 0.1) * dY
                if (bl.pins.bottom.length)
                    bl.pins.bottom[0].bind.forEach(b => b.block = rez.n.get(b.block));
            } )
            if (rez.data.length)
                rez.data[0].pins.top = [];
            return rez.data;
        }
    })

    ODA({ is: 'oda-net-node', imports: '@oda/button',
        template: /*HTML*/ `
            <style>
                :host {
                    @apply --border;
                }
                #label {
                    margin-right:20px;
                }
                input {
                    border:none; width:5em;
                    background:#00000022 !important;
                    outline:none;
                    font-size: inherit;
                    text-align:right;
                }
                div{
                    padding: 4px;
                }
                oda-button{
                    font-size: xx-small;
                }
            </style>
            <div dark class="horizontal dark">
                <div class="flex">{{label}}</div>
                <div>{{shape}}</div>
            </div>
            <div class="horizontal">
                <oda-button flex>data</oda-button>
                <oda-button flex>grad</oda-button>
            </div>
        `,
        get tensor(){
            return this.block.tensor;
        },
        get shape(){
            return this.tensor?.shape?.join('X')
        },
        get label(){
            return this.tensor?.label;
        },
        get isInput() {
            if (this.tensor.children.length!==0) return false
            if (this.tensor.t === 'param') return false
            return true

        },
        get border() {
            if (this.tensor.t === 'param') return 'green'
            if (this.tensor.t === 'fictive') return 'white'
            if (this.tensor.t === 'output') return 'orange'
            if (this.isInput) return 'blue'
            return 'silver'
        },
        onInput(e){
            this.tensor.data = e.target.value;
            this.simpleNet.step()

        },
    })
    function tensor(...params){
        return new Tensor(...params);
    }
</script>