<meta charset="utf-8">
<morpheus-designer></morpheus-designer>
<script type="module">
    import '../../../oda.js';
    import {Morph2vec, Tokenizer} from './morpheus.js';
    ODA({is:'morpheus-designer', imports: '@oda/button, @oda/app-layout, @tools/property-grid, @tools/containers', extends: 'oda-app-layout',
        template: `
        <style>
            :host{
                @apply --header;
            }
        </style>
        <div class="horizontal shadow flex  header" slot="header" style="align-items: center; margin-bottom: 1px;">
          <div class="horizontal no-flex" style="z-index: 1">
            <oda-button icon="icons:note-add" :icon-size @tap="create"></oda-button>
            <oda-button icon="icons:file-upload" :icon-size @tap="load"></oda-button>
            <oda-button :disabled="!model?.isChanged" icon="icons:save" :icon-size @tap="save"></oda-button>
          </div>
          <div class="horizontal flex" style="justify-content: center;">
            <span ~if="model" class="bold no-flex" style="font-size: x-large; text-align: center; padding: 4px 16px; border-radius: 8px; flex-wrap: nowrap; text-overflow: ellipsis;">{{model?.label}}</span>
          </div>
          <div class="horizontal no-flex" style="align-items: center" ~if="model">
<!--                <oda-button  icon="icons:help" @tap="model.reTrain(); model.calcError();">retrain</oda-button>-->
<!--            <oda-button :disabled="!model?.size" allow-toggle ::toggled="train" class="content bold"  style="border-radius: 8px; margin: 8px;" :icon="train?'av:stop':'av:play-circle-outline'" :error="train" :success="!train">TRAIN</oda-button>-->
            <oda-button  icon="icons:settings" @tap="settings"></oda-button>
          </div>
        </div>
        <div  class="horizontal header flex" slot="footer" style="align-items: center; border-top: 2px solid white; height: 32px;">
             <span ~if="progress" class="border" style="margin: 4px; width: 150px; height: 10px; background-color: silver; text-align: center;" ~style="progressStyle"></span>
             <span style="margin: 4px">error: {{Math.round((model?.error || 0) * 10000)/100+'%'}}</span>
        </div>
        <oda-prime-sources ~if="model"  slot="left-panel" title="sources" opened icon="av:library-books"></oda-prime-sources>
        <oda-morph-compare-tester ~if="model"  slot="left-panel" title="tester (compare)" icon="office-set:analytics"></oda-morph-compare-tester>
        <oda-morph-near-tester ~if="model"  slot="left-panel" title="tester (near)" icon="enterprise:percentage"></oda-morph-near-tester>
        <oda-prime-model ~if="model"  :model slot="main"></oda-prime-model>
        <!--        <oda-property-grid :inspected-object slot="right-panel"></oda-property-grid>-->
        `,
        get progressStyle(){
            return {background: `linear-gradient(90deg, green ${this.progress}%, silver ${this.progress}%)`}
        },
        progress: 0,
        async settings(e){
            await ODA.showDropdown(
                'oda-property-grid',
                { inspectedObject: this.model, style: 'min-width: 500px' },
                { parent: e.target, intersect: true, align: 'right', title: 'Settings', hideCancelButton: true }
            );
        },
        train(tokenizer){
            const tree = tokenizer.morphTree;
            const tokens = Object.keys(tree);
            const size = tokens.length;
            let step = -1;
            const trainer = ()=>{
                let token = tokens[++step];
                if (this.model.train(token, tree) === undefined){
                    this.progress = 0;
                    return;
                }
                this.progress = Math.round(step/size * 10000)/100;
                this.async(trainer)
            }
            trainer();
        },
        async create(){
            const result = await ODA.showDialog('oda-prime-create-model', {}, {title: 'Create new m2v model'});
            const opts = {
                types: [{
                    description: 'm2v file',
                    accept: {'application/m2v': ['.m2v']},

                }],
                suggestedName: 'Morph2Vec ' + result.vectorSize +'-'+result.windowSize +'-'+result.negativeSize,
                excludeAcceptAllOption: true
            };
            const fileHandle = await window.showSaveFilePicker(opts);
            const writable = await fileHandle.createWritable();
            const model = new Morph2vec({name: fileHandle.name.split('.')[0], vectorSize: result.vectorSize})
            model.windowSize = result.windowSize;
            model.negativeSize = result.negativeSize;
            const contents = JSON.stringify(model.data);
            await writable.write(contents);
            await writable.close();
            this.model = model;
        },
        async load(){
            const opts = {
                types: [{
                    description: 'Json file',
                    accept: {'application/m2v': ['.m2v']},
                }],
                excludeAcceptAllOption: true,
                multiple: false
            };
            const [fileHandle] = await window.showOpenFilePicker(opts);
            const file = await fileHandle.getFile();
            const reader = new FileReader();
            reader.onload = (e) =>{
                this.model = new Morph2vec(JSON.parse(e.target.result));
            }
            reader.readAsText(file);
        },
        async save(){
            if (!this.model)
                return;
            const opts = {
                types: [{
                    description: 'm2v file',
                    accept: {'application/m2v': ['.m2v']},

                }],
                suggestedName: this.model.name,
                excludeAcceptAllOption: true
            };
            const fileHandle = await window.showSaveFilePicker(opts);
            const writable = await fileHandle.createWritable();
            this.model.name = fileHandle.name.split('.')[0]
            const contents = JSON.stringify(this.model.data);
            await writable.write(contents);
            await writable.close();
            this.model.isChanged = false;
        },
        get inspectedObject(){
            return this.querySelector('oda-prime-trainer') || undefined;
        },
        $pdp:{
            model: null,
        },
        $public:{
            name:{
                $def: 'Morph2Vec',
                $save: true,
            },
            iconSize: 32,
            autoSize: true
        }
    })
    ODA({is:'oda-prime-create-model',
        template:`
        <style>
            :host{
                @apply --vertical;
                padding: 16px;
            }
            div{
                padding: 4px;
                @apply --flex;
                @apply --horizontal;
                align-items: center;
            }
            input{
                font-size: x-large;
                width: 150px;
                text-align: right;
                @apply --no-flex;
                margin-left: 8px;
            }
            label{
                @apply --flex;
            }
        </style>
        <div class="horizontal">
          <label>Vector size</label>
          <input type="number" ::value="vectorSize">
        </div>
        <div class="horizontal">
          <label>Window size</label>
          <input type="number" ::value="windowSize">
        </div>
        <div class="horizontal">
          <label>Negative size</label>
          <input type="number" ::value="negativeSize">
        </div>
        `,
        $public:{
            vectorSize:{
                $def: 16,
                $save: true
            },
            windowSize:{
                $def: 2,
                $save: true
            },
            negativeSize:{
                $def: 2,
                $save: true
            }
        }
    })
    ODA({is: 'oda-prime-sources',
        template:`
        <style>
            :host{
                @apply --flex;
                @apply --vertical;
                overflow: hidden;
            }
            span{
                font-size: small;
            }
        </style>
        <oda-button class="dark" icon="icons:add" @tap="loadFile">Add corpus</oda-button>
        <div class="vertical flex" style="overflow-y: auto;">
            <div ~for="sources" class="vertical border" style="padding: 4px 8px;">
              <label>{{item.name}}</label>
              <span>{{item.tokens}} tokens from {{item.size}} bytes</span>
            </div>
        </div>
        `,
        get sources(){
            return this.model?.data?.sources;
        },
        async saveData(e){
            await ODA.saveJSON(this.model.data.name+".json", this.model.data);
            this.model.isChanged = false;
        },
        async loadFile(e){
            const opts = {
                types: [{
                    description: 'Json file',
                    accept: {'text/plain': ['.txt']},
                }],
                excludeAcceptAllOption: true,
                multiple: true
            };

            const files = await window.showOpenFilePicker(opts);
            for (let fileHandle of files) {
                const file = await fileHandle.getFile();
                const reader = new FileReader();
                reader.onload = (e) =>{
                    const tokenizer = new Tokenizer(e.target.result, this.model);
                    tokenizer.file = file;
                    if (this.model.data.sources.some(i=>{
                        return i.checksum === tokenizer.checksum;
                    })) throw new Error(`Corpus ${tokenizer.checksum} already exist in model`);
                    const source = {name: tokenizer.file.name, size: tokenizer.file.size, tokens: Object.keys(tokenizer.morphTree).length, checksum: tokenizer.checksum};
                    this.model.data.sources.push(source);
                    const train = ()=>{
                        this.model.train(tokenizer);
                        this.model.calcError();
                        if (this.model.error<0.05) return
                        // this.async(train);
                    }
                    train();
                    this.model.isChanged = true;
                }
                reader.readAsText(file);
            }
        },
    })
    ODA({is:'oda-morph-compare-tester',
        template:`
          <style>
              :host{
                  @apply --flex;
                  @apply --vertical;
                  overflow-y: auto;
              }
          </style>
          <oda-morph-test ~for="model?.tests" :test="item"></oda-morph-test>
          <oda-button class="dark" icon="icons:add" @tap="model?.addTest()">Add test</oda-button>
        `
    })

    ODA({is:'oda-morph-test',
        template:`
            <style>
                :host{
                    @apply --vertical;
                    @apply --shadow;
                    padding: 2px 0px;
                }
                input{
                    margin: 2px;
                    text-align: center;
                    font-size: x-large;
                    border: none;
                }
                span{
                    text-align: center;
                    font-size: small;
                }
                .result{
                    background-color: {{color}} !important;
                }
            </style>
            <div class="horizontal flex">
                <div class="vertical flex" style="width: 50%">
                    <input class="flex" ::value="test.word1">
<!--                    <span  class="flex">{{morphs1}}</span>-->
                </div>
                <div class="vertical flex"  style="width: 50%">
                    <input  class="flex" ::value="test.word2">
<!--                    <span  class="flex">{{morphs2}}</span>-->
                </div>
            </div>
            <div class="horizontal flex" style="align-items: center;">
                <span class="result flex content bold" style="text-align: center">{{result}}</span>
                <oda-button icon="icons:close" @tap="deleteTest"></oda-button>
            </div>

        `,
        test: {},
        get result(){
            return  this.model.similarWords(this.test.word1, this.test.word2)
        },
        get morphs1(){
            return this.model.getWordTokens(this.test.word1)?.join('-');
        },
        get morphs2(){
            return this.model.getWordTokens(this.test.word2)?.join('-');
        },
        get color(){
            if (this.result === undefined) return undefined
            const getColor = (val) => {
                val = Math.abs(val);
                return 90 * val//(val * val)/2;
            }
            return `hsl(${getColor(this.result)}, 100%, 50%)`;
        },
        deleteTest(e){
            this.model.deleteTest(this.test);
        }
    })



    ODA({is:'oda-morph-near-tester',
        template:`
          <style>
              :host{
                  @apply --flex;
                  @apply --vertical;
                  overflow: hidden;
              }
              input{
                  margin: 8px;
                  font-size: x-large;
              }
          </style>
          <input class="no-flex" ::value>
          <div class="flex vertical" style="overflow: auto;">
              <div ~for="rating" class="border no-flex horizontal" style="padding: 4px; overflow-y: auto">
                  <span class="flex">{{item?.word}}</span>
                  <span class="no-flex">{{item?.percent}}%</span>
              </div>
          </div>
        `,
        value: '',
        get rating(){
            return this.model.getSimilarRating(this.value);
        }
    })


    ODA({is: 'oda-prime-model', imports: '@oda/table', extends: 'oda-table',
        get columns() {
            const v_size = this.model?.vectorSize;
            return [
                {name: 'id',  fix: 'left',  width: 80, style: 'text-align: right'},
                {name: 'token',  fix: 'left', template: 'oda-prime-token', treeMode: true},
                {name: 'embedding', width: 500,   template: 'morpheus-table-cell-vector', align: 'right'},
            ]
        },
        get dataSet(){
            return this.model?.items;
        },
        $public:{
            allowSort: false,
            // allowFocus: true,
            // autoWidth: true,
            colLines: true,
            // rowLines: true,
            showHeader: true,
            showFooter: true,
            lazy: true,
            evenOdd: true
        },
        set model(model){
            this.dataSet = undefined;
            model?.listen('update', ()=>{
                // this.interval('dataset-update', ()=>{
                //     this.dataSet = undefined;
                // }, 100)
                this.interval('error-update', ()=>{
                    model.calcError();
                }, 100)
            })
            return model;
        }
    })

    ODA({is:'oda-prime-token', extends: 'oda-table-cell-base',
        template: `
        <span class=" bold flex">{{value}}</span>
        <span style="padding: 4px" class="no-flex">[{{cnt}}]</span>
        `,
        get value(){
            return this.item?.[this.column.name];
        },
        get cnt(){
            return Object.keys(this.item?.links || {}).length;
        }
    })

    ODA({is:'oda-prime-num', extends: 'oda-table-cell-base',
        template: `
        <style>
            :host{
                text-align: right;
                @apply --horrizontal;
            }
            span{
                padding: 4px;
            }
        </style>
        <span class="flex">{{text}}</span>
        `,
        get v(){
            return this.item.$level?'0':'';
        },
        get text(){
            if(this.value === undefined)
                return this.v;
            return this.value.toLocaleString(undefined, {minimumFractionDigits: 6, maximumFractionDigits: 6});
        },
        get value(){
            return this.item?.[this.column.name];
        },
    })

    ODA({is:'morpheus-table-cell-vector', extends: 'oda-table-cell-base',
        template: `
        <style>
            :host{
                @apply --flex;
                @apply --horizontal;
                /*padding: 4px;*/
            }
            div{
                width: 100%;
                height: 100%;
                background: linear-gradient(to right, {{getColors()}});
            }
        </style>
        <div class="flex"></div>
        `,
        $public:{
            min: -2,
            max: 2,
            step: 3,
        },
        get size(){
            return this.value?.length;
        },
        get value(){
            return this.item?.[this.column.name];
        },
        getColors(){
            const getColor = (val)=>{
                return 360 * val;
            }
            return this.value?.map((val, idx, items)=>{
                return `hsl(${getColor(val)}, 100%, 50%) ${((idx+1)/items.length) * 100}%, hsl(${getColor(items[idx+1] || 0)}, 100%, 50%)  ${((idx+1)/items.length) * 100}%`;
            }).join(', ');
        }
    })
</script>