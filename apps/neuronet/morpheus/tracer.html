<meta charset="UTF-8">
<title>Title</title>
<oda-gpt id="gpt"></oda-gpt>
<script type="module">
    import '../../../oda.js';
    import '../../../tools/containers/containers.js';
    ODA({is: 'oda-gpt', imports: '@oda/app-layout', extends: 'oda-app-layout',
        template: `
          <div class="flex vertical" slot="left-panel" opened>
              <div class="horizontal dark" style="padding:4px;">
                  <oda-button icon="icons:note-add" :icon-size @tap="create"></oda-button>
                  <oda-button icon="icons:file-upload" :icon-size @tap="load"></oda-button>
                  <oda-button :disabled="!model?.isChanged" icon="icons:save" :icon-size @tap="save"></oda-button>
                  <oda-button class="dark" icon="icons:add" @tap="loadFile">Add corpus</oda-button>
                  <div flex></div>
                  <oda-button :icon="train?'av:stop':'av:play-circle-filled'" :error="!!train"  @tap="train = !train">{{train?'stop':'train'}}</oda-button>
              </div>
              <fieldset class="vertical"  style="border-radius: 4px; min-width: 0px;">
                  <legend bold>SIMILAR:{{Math.round(similar * 100)}}%</legend>
                  word 1:
                  <div horizontal>
                      <input ::value="w1">
                      <div border flex style="height: 20px;" ~style="grad1"></div>
                  </div>
                  word 2:
                  <div horizontal>
                      <input ::value="w2">
                      <div border flex style="height: 20px;" ~style="grad2"></div>
                  </div>
              </fieldset>
              <fieldset class="flex vertical"  style="border-radius: 4px; min-width: 0px;">
                  <legend bold>PREDICATE</legend>
                  text:
                  <textarea ::value="text"></textarea>
                  <div border style="height: 20px;" ~style="grad3"></div>
                  predicate:
                  <textarea flex>{{predicate}}</textarea>
              </fieldset>
          </div>
          <div slot="main" class="flex vertical" style="overflow-y: auto">
              <div dark border ~for="tokens" class="horizontal" >
                    <div class="horizontal" style="width: 80px; text-align: left; padding: 4px 8px; justify-content: space-between">
                        <div>{{$for.key}}</div>
                        <button @tap="showLinks" :token="$for.key" style="width: 50%;">{{Object.keys(model.tokens[$for.key].map).length}}</button>
                    </div>
                    <div border class="flex" ~style="getBackGradient($for.item.emb)"></div>
                    <div style="width: 50px; text-align: right; padding: 4px 8px;">{{Math.round($for.item.error * 1000)/10}}%</div>
              </div>
          </div>
          <div class="horizontal header bold" slot="footer">
              <style>
                div{
                    padding: 4px;
                    font-size: small;
                }
              </style>
              <div>TOKENS: {{size.toLocaleString()}}</div>
              <div>TRAINED: {{model.count.toLocaleString()}}</div>
              <div>ERROR: {{Math.round(error * 1000)/10}}%</div>
          </div>
        `,
        async loadFile(e){
            const opts = {
                types: [{
                    description: 'text file',
                    accept: {'text/plain': ['.txt']},
                },
                {
                    description: 'JS file',
                    accept: {'text/javascript': ['.js'] },
                }
            ],
                excludeAcceptAllOption: true,
                multiple: true
            };

            const files = await window.showOpenFilePicker(opts);
            for (let fileHandle of files) {
                const file = await fileHandle.getFile();
                const reader = new FileReader();
                reader.onload = (e) =>{
                    this.corpus = e.target.result;
                }
                reader.readAsText(file);
            }
        },
        get size(){
            return Object.keys(this.tokens).length;
        },
        get error(){
            if (!this.size)
                return 1;
            const sum = Object.values(this.tokens).reduce((res,i)=>{
                res += i.error;
                return res;
            }, 0);
            return sum/this.size;
        },
        async showLinks(e){
            const token = e.target.getAttribute('token')
            const {result} = await ODA.showDropdown('oda-token-links', {token}, {title: token, parent: e.target, align: 'right', anchor: 'top-right'});
        },
        getBackGradient(vector){
            return {background: `linear-gradient(to right, ${this.getColors(vector)})`}
        },
        get predicate(){
            let text = this.text;
            const result = Object.create(null);
            const join = [];
            for (let t = 0; t < text.length; t++){
                const token = text.substr(t, this.winSize);
                if (token.length<2) continue;
                const next =  this.model.tokens[token];
                const emb = next.emb;
                for(let i = 0; i < emb.length; i++){
                    join[i] ??= emb[i];
                    join[i] = (join[i] + emb[i]) / 2;
                }
                result[token] = next.map;
            }
            return JSON.stringify(result, null, 2);
        },
        text: {
            $def: '',
            set(n){
                scan(n, .1);
            },
            $save: true,
        },
        get grad1(){
            return this.getBackGradient(this.join(this.w1));
        },
        get grad2(){
            return this.getBackGradient(this.join(this.w2));
        },
        get grad3(){
            return this.getBackGradient(this.join(this.text));
        },
        w1:{
            $def: '',
            $save: true,
        },
        w2:{
            $def: '',
            $save: true,
        },
        get similar(){
            return  this.similarWords(this.w1, this.w2);
        },
        similarWords(t1, t2){
            t1 = this.join(t1);
            t2 = this.join(t2);
            return cosSimilar(t1, t2);
        },
        set corpus(n){
            this.scan(n);
        },
        scan(word){
            scan(word);
            this.predicate = undefined;
            this.size = undefined;
            this.error = undefined;
            this.similar = undefined;
        },
        join(word){
            this.scan(word);
            const result = [];
            for (let t = 0; t < word.length; t++){
                const token = word.substr(t, this.winSize);
                if (token.length<2) continue;
                const emb = this.model.tokens[token].emb;
                for(let i = 0; i < emb.length; i++){
                    if (result[i] === undefined)
                        result[i] = emb[i];
                    else
                        result[i] = (result[i] + emb[i])/2;
                }
            }
            return result;
        },
        set train(n){
            if (n){
                this._interval = setInterval(()=>{
                    this.scan(this.corpus);
                },10)
            }
            else{
                clearInterval(this._interval);
            }
        },
        getColors(items){
            const getColor = (val)=>{
                return 360 * val;
            }
            return items?.map((val, idx, items)=>{
                return `hsl(${getColor(val)}, 100%, 50%) ${((idx+1)/items.length) * 100}%, hsl(${getColor(items[idx+1] || 0)}, 100%, 50%)  ${((idx+1)/items.length) * 100}%`;
            }).join(', ');
        },
        get tokens(){
            return this.model.tokens;
        },
        get winSize(){
            return this.model.winSize;
        },
        model: Object,
    })
    ODA({is: 'oda-token-links',
        template:`
            <style>
                :host{
                    @apply --vertical;
                }
                div{
                    padding: 4px 8px;
                    border-bottom: 1px solid silver;
                }
                div:hover{
                    @apply --active;
                }
            </style>
            <div @tap="result = $for.key" ~for="links" class="horizontal">
                <span class="flex">{{$for.key}}</span>
                <span>{{$for.item}}</span>
            </div>
        `,
        token: '',
        get links(){
            return model.tokens[this.token].map;
        },
        set result(n){
            this.fire('ok', n);
        }
    })
    const negSize = 2;
    const model = {
        error: 1,
        count: 0,
        winSize: 2,
        negSize,
        dimension: 4,
        tokens: Object.create(null),
    }
    gpt.model = model;
    let tokenList;
    let negPos = 0;
    function scan(text, plastic = 1){
        if (!text) return;
        let {winSize, dimension, negSize} = model;
        let prevToken = '';
        let predPredicate = [...Array(dimension)].map(i=>(0));
        let tokenItem;
        const array = [...Array(dimension)];
        const array1 = [...Array(dimension/2)];
        tokenList ??= Object.keys(model.tokens);
        for (let i = 0; i < text.length; i++){
            const token = text.substr(i, winSize);
            if (token.length === 2){
                tokenItem = model.tokens[token];
                if (!tokenItem){
                    tokenItem = model.tokens[token] = Object.create(null);
                    tokenItem.error = 1;
                    tokenItem.map = Object.create(null);
                    tokenItem.emb = array.map(i=>(Math.random() - .5));
                    tokenItem.cnt = array.map(i=>(Math.random() - .5));
                    tokenItem.net = [array1.map(i => array.map(i=>(Math.random() - .5))), array.map(i => array1.map(i=>(Math.random() - .5)))];
                    tokenList = Object.keys(model.tokens);
                }
                if (prevToken?.length){
                    let prevTokenItem = model.tokens[prevToken];
                    prevTokenItem.map[token] ??= 0;
                    prevTokenItem.map[token]++;
                    const trainData = [{cur: prevTokenItem, next: tokenItem, target: 1, sum: 0}]
                    for (let n = 0; n<negSize; n++){ // поиск негативных токенов
                        if (negPos >= tokenList.length)
                            negPos = 0;
                        while(++negPos < tokenList.length){
                            const neg = tokenList[negPos];
                            if (!prevTokenItem.map[neg]){
                                trainData.push({next: model.tokens[neg], target: 0, sum: 0});
                                break;
                            }
                        }
                    }
                    train(trainData, predPredicate);
                }
            }
            prevToken = token;
        }
        Object.assign(model, {winSize, dimension, negPos});
    }
    function train(data, pp){
        if (data.length < negSize + 1)
            return;
        model.count++;
        let emb = data[0].cur.emb;
        for (let d of data){
            d.cnt ??= d.next.cnt;
        }
        for (let i = 0; i <emb.length; i++) {
            const e = emb[i];
            for (let d of data){
                d.sum += d.cnt[i] * e;
            }
        }
        let error = 1;
        for (let d of data){
            d.predicate = 1 / (1 + Math.exp(-d.sum));
            d.loss = d.target - d.predicate;
            error = (error + Math.abs(d.loss))/2;
            d.sigma = d.loss * d.predicate * (1 - d.predicate)
        }

        for (let i = 0; i <emb.length; i++) {
            const e = emb[i];
            let sum = 0;
            for (let d of data){
                const c = d.cnt[i];
                sum += c * d.sigma;
                d.cnt[i] +=  d.sigma * e * .1;
            }
            emb[i] += sum *  .1;
            pp[i] ??= emb[i];
            pp[i] = (pp[i] + emb[i])/2;

        }
        data[0].cur.error = error;

        const net = data[0].cur.net;
        let layer1 = net[0];
        const res1 = [];
        for (let l = 0; l < layer1.length; l++){
            const ww = layer1[l];
            let sum = 0;
            for (let i = 0; i <emb.length; i++){
                sum += emb[i] * ww[i];
            }
            res1[l] = 1/(1 + Math.exp(-sum));
        }
        let layer2 = net[1];
        const loss = [];
        const res2 = [];
        emb = data[0].next.emb;
        for (let l = 0; l < layer2.length; l++){
            const ww = layer2[l];
            let sum = 0;
            for (let i = 0; i <res1.length; i++){
                sum += res1[i] * ww[i];
            }
            res2[l] = sum;
            loss[l] = sum - emb[l];
        }

        for (let l = 0; l < layer2.length; l++){
            const ww = layer2[l];
            let sum = 0;
            const err = loss[l];
            for (let i = 0; i <ww.length; i++){
                sum += err * ww[i];
            }
            for (let i = 0; i <ww.length; i++){
                ww[i] += sum  * res1[i] * .1;
            }
        }

    }
    function cosSimilar(A, B) { //На входе 2 вектора
        if (!A || !B) return 0;
        const m = A?.length || 0;
        let scalar = 0;
        let avgA = 0;
        let avgB = 0;
        for (let i = 0; i < m; i++){
            let a = A[i];
            let b = B[i];
            scalar += a * b;
            avgA += a * a;
            avgB += b * b;
        }
        return Math.abs((scalar && scalar / (Math.sqrt(avgA) * Math.sqrt(avgB))) || 0) ;
    }
</script>