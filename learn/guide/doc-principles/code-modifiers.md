Стандартный блок подсветки синтаксиса кода «**Markdown**» позволяет отображать текст, форматируя его определенным образом, в зависимости от его типа.

Тип форматирования задается в заголовке блока после трех символов грависа (обратных апострофов).

Например,

```text hideGutter
    ```javascript
    let newElement = document.createElement('div');
    newElement.innerHTML = '<input placeholder="Модификатор run">';
    document.body.append(newElement);
    ```
```

В этом примере указан тип «**javascript**», который говорит о том, что текст внутри блока написан на языке «**JavaScript**» и его необходимо подсвечивать в соответствии с синтаксисом данного языка.

```javascript
let newElement = document.createElement('div');
newElement.innerHTML = '<input placeholder="Модификатор run">';
document.body.append(newElement);
```

В нашей системе документации стандартные возможности блока подсветки кода «**Markdown**» были расширены специальными модификаторами, к которым относятся:

1. Модификатор «**run**» позволяет блоку не только подсвечивать код определенным образом, но и выполнять его.

    Например,

    ```text hideGutter
        ```javascript run
        let newElement = document.createElement('div');
        newElement.innerHTML = '<input placeholder="Модификатор run">';
        document.body.append(newElement);
        ```
    ```

    При его использовании под редактором кода появляется дополнительная область, в которую можно вывести результат выполнения этого кода при условии, что он был написан на языке «**JavaScript**». Для этого в заголовке блока нужно указать модификатор «**javascript**».

    ```javascript run
    let newElement = document.createElement('div');
    newElement.innerHTML = '<input placeholder="Модификатор run">';
    document.body.append(newElement);
    ```

    Область вывода представляет собой плавающий фрейм (HTML-элемент «**iframe**»), в котором автоматически формируется стандартный HTML-документ. В заголовок этого документа добавляется тэг «**script**» с типом «**module**». В тело этого скрипта записывается код, указанный в редакторе. При загрузке страницы этот документ добавляется в область вывода, автоматически выполняя при этом указанный скрипт. В этом скрипте можно предусмотреть вывод всех элементов, необходимых для отображения результата его выполнения.

    ![iFrame блока кода] (https://odajs.org/learn/images/doc-principles-iframe-red.png "iFrame блока кода")

1. Модификатор «**edit**» говорит о том, что текст блока можно будет редактировать.

    Этот модификатор задается следующим образом:

    ```text hideGutter
        ```javascript run_edit
        let newElement = document.createElement('div');
        newElement.innerHTML = '<input type="number" placeholder="Модификатор edit">';
        document.body.append(newElement);
        ```
    ```

    Если одновременно указать оба модификатора: «**run**» и «**edit**», как в этом примере, то любое изменение кода в редакторе будет мгновенно приводить к его выполнению.

    Например,

    ```javascript run_edit
    let newElement = document.createElement('div');
    newElement.innerHTML = '<input type="number" placeholder="Модификатор edit">';
    document.body.append(newElement);
    ```

    Если в этом примере тип элемента «**input**» поменять с «**number**» на «**radio**» или на любой другой разрешенный тип, то можно убедиться, что все сделанные изменения немедленно отобразятся в области вывода.

    ```warning hideGutter
    Обратите внимание, что если во время редактирования код будет содержать ошибки, то в окне вывода никакой результат выводится не будет.
    ```

1. Модификатор «**copy**» позволяет отобразить дополнительную кнопку в верхнем правом углу редактора, с помощью которой можно будет скопировать весь текст, написанный в блоке, без дополнительного его выделения.

    Он задается следующим образом:

    ```text hideGutter
        ```javascript run_copy
            let newElement = document.createElement('div');
            newElement.innerHTML = '<input type="text" placeholder="Модификатор copy">';
            document.body.append(newElement);
        ```
    ```

    В этом случае нет необходимости выделять весь текст и нажимать сочетание клавиш «Ctrl+C», чтобы скопировать его. Это будет сделано автоматически при нажатии на кнопку «**copy**».

    Например,

    ```javascript run_copy
    let newElement = document.createElement('div');
    newElement.innerHTML = '<input type="text" placeholder="Модификатор copy">';
    document.body.append(newElement);
    ```

    Чтобы проверить работоспособность этой кнопки, нажмите на нее левой кнопкой мыши и вставьте скопированный текст в элемент «**input**» данного примера.

1. Модификатор Web-компонента «**[имя-компонента.js]**» говорит о том, что в тело HTML-документа, который используется для вывода результата, будет автоматически добавлен тэг пользовательского компонента с именем, указанным в квадратных скобках без расширения «**.js**».

    Например,

    ```text hideGutter
        ```javascript run_edit_[my-component.js]
        ODA({
            is: 'my-component',
            template: `
                <input type="number" placeholder="Модификатор Web-компонента">
            `
        });
        ```
    ```

    Фактически этот тэг (**\<my-component>\</my-component>**) станет хостом одноименного пользовательского компонента.

    Кроме этого, к заголовку HTML-документа, который используется для вывода результата, будет автоматически подключена библиотека «**oda.js**». В следствии этого ODA-компонент, записанный в редакторе кода, будет отображаться в окне вывода без подключения каких-либо дополнительных элементов.

    ```javascript run_edit_[my-component.js]
    ODA({
        is: 'my-component',
        template: `
            <input type="text" placeholder="Модификатор Web-компонента">
        `
    });
    ```

    Без модификатора Web-компонента «**[имя-компонента.js]**» тэг пользовательского компонента пришлось бы создавать в теле HTML-документа в ручном режиме. Например, вот так.

    ```javascript run_edit
        ODA({
            is: 'my-component',
            template: `
                <input type="text" placeholder="Модификатор Web-компонента">
            `
        });
        let myComponent = document.createElement('my-component');
        document.body.append(myComponent);
    ```

    ```info md
    Следует отметить, что библиотека «oda.js» подключается к HTML-документу автоматически только при указании модификаторов «**javascript**» или web-компонента «**[имя-компонента.js]**». Во всех остальных случаях ее придется подключать отдельно.
    ```

    Например, если в качестве типа указать модификатор «**html**», то все подключения, необходимые для отображения ODA-компонента, придется делать в ручном режиме.

    ```html run_edit
    <!DOCTYPE html>
    <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Welcome to ODA.js</title>
            <script type="module" src="https://cdn.jsdelivr.net/gh/odajs/oda/oda.js"></script>
            <script type="module">
                ODA({
                    is: 'my-component',
                    template: `
                        <span>Привет, ODA-компонент!</span>
                    `
                });
            </script>
        </head>
        <body>
            <my-component></my-component>
        </body>
    </html>
    ```

    Как видно из этого примера, его код становится намного сложней. Он перенасыщен неважными с точки зрения понимания работы ODA-компонента элементами.

    Кроме этого, написанный в области редактора скрипт автоматически получает имя, указанное в квадратных скобках модификатора компонента. Например, «**my-component.js**». Это имя можно будет использовать в дальнейшем для создания наследников данного компонента в других примерах.

1. Модификатор родительского компонента «**{имя-родительского-компонента.js}**» позволяет к текущему примеру автоматически подключить скрипт с кодом родительского компонента.

    Для использования этого модификатора сначала необходимо объявить родительский компонент.

    ```text hideGutter
        ```javascript run_edit_[base-component.js]
        ODA({
            is: 'base-component',
            template: `
                <div>Родитель</div>
            `
        });
        ```
    ```

    Родительский компонент будет выводиться обычным образом, но его скрипт получит имя, указанное в квадратных скобках. В данном случае это имя «**base-component.js**».

    ```javascript run_edit_[base-component.js]
    ODA({
        is: 'base-component',
        template: `
            <div>Родитель</div>
        `
    });
    ```

    После этого, в блоке наследника можно подключить скрип с кодом родительского компонента, указав его имя в фигурных скобках.

    ```text hideGutter
        ```javascript run_edit_[my-component.js]_{base-component.js}
        ODA({
            is: 'my-component',
            extends: 'base-component',
            template: `
                <div>Наследник</div>
            `
        });
        ```
    ```

    В результате этого в текущем блоке не придется повторно объявлять родительский компонент, усложняя тем самым код примера с наследником.

    ```javascript run_edit_[my-component.js]_{base-component.js}_h=40_
    ODA({
        is: 'my-component',
        extends: 'base-component',
        template: `
            <div>Наследник</div>
        `
    });
    ```

    Если у компонента будет несколько родителей, то все их имена необходимо перечислить в фигурных скобках последовательно друг за другом, отделяя одно имя от другого символом подчеркивания.

    Например, объявим первого родителя с именем «**base-component-1**».

    ```text hideGutter
        ```javascript run_edit_[base-component-1.js]
        ODA({
            is: 'base-component-1',
            template: `
                <div>Родитель 1</div>
            `
        });
        ```
    ```

    Первый родитель будет выводится обычным образом.

    ```javascript run_edit_[base-component-1.js]
    ODA({
        is: 'base-component-1',
        template: `
            <div>Родитель 1</div>
        `
    });
    ```

    Второго родителя объявим с именем скрипта «**base-component-2.js**».

    ```text hideGutter
        ```javascript run_edit_[base-component-2.js]
        ODA({
            is: 'base-component-2',
            template: `
                <div>Родитель 2</div>
            `
        });
        ```
    ```

    Он будет выводится так же, как и первый родитель.

    ```javascript run_edit_[base-component-2.js]
    ODA({
        is: 'base-component-2',
        template: `
            <div>Родитель 2</div>
        `
    });
    ```

    При объявлении наследника, подключим к его блоку скрипты двух предыдущих компонентов, указав их имена в фигурных скобках, отделяя их друг от друга символом подчеркивания.

    ```text hideGutter
        ```javascript run_edit_[my-component.js]_{base-component-1.js_base-component-2.js}
        ODA({
            is: 'my-component',
            extends: 'base-component-1, base-component-2',
            template: `
                <div>Наследник</div>
            `
        });
        ```
    ```

    В результате этого наследник приобретет все элементы своих родителей, несмотря на то, что в его блоке родительские компоненты не будут явно объявлены.

    ```javascript run_edit_[my-component.js]_{base-component-1.js_base-component-2.js}_h=55_
    ODA({
        is: 'my-component',
        extends: 'base-component-1, base-component-2',
        template: `
            <div>Наследник</div>
        `
    });
    ```

    Это существенно упрощает понимание работы наследника, не отягощая его код лишней информацией о всех его родителях.

1. Модификатор «**h=значение**» позволяет задать фиксированную высоту области вывода результата в пикселях.

    По умолчанию высота окна вывода определяется автоматически по высоте контента результата так, чтобы стандартная полоса прокрутки никогда не появлялась.

    Например,

    ```javascript run_edit_[my-component.js]
    ODA({
        is: 'my-component',
        template: `
            <div>Съешь же ещё этих мягких французских булок да выпей чаю. Эй, жлоб! Где туз? Прячь юных съёмщиц в шкаф. Друг мой эльф! Яшке б свёз птиц южных чащ! В чащах юга жил бы цитрус? Да, но фальшивый экземпляр! Широкая электрификация южных губерний даст мощный толчок подъёму сельского хозяйства. Шеф взъярён тчк щипцы с эхом гудбай Жюль.</div>
        `
    });
    ```

    Однако высоту этого окна можно ограничить так, чтобы оно всегда имело фиксированный размер. Для этого достаточное указать требуемое значение в пикселях, при этом единицы измерения отдельно указывать не нужно.

    ```text hideGutter
        ```javascript run_edit_[my-component.js]_h=20_
        ODA({
            is: 'my-component',
            template: `
                <div>Съешь же ещё этих мягких французских булок да выпей чаю. Эй, жлоб! Где туз? Прячь юных съёмщиц в шкаф. Друг мой эльф! Яшке б свёз птиц южных чащ! В чащах юга жил бы цитрус? Да, но фальшивый экземпляр! Широкая электрификация южных губерний даст мощный толчок подъёму сельского хозяйства. Шеф взъярён тчк щипцы с эхом гудбай Жюль.</div>
            `
        });
        ```
    ```

    В этом случае стандартная полоса прокрутки будет появляться всегда, как только действительная высота результата превысит указанное значение.

    Например,

    ```javascript run_edit_[my-component.js]_h=20_
    ODA({
        is: 'my-component',
        template: `
            <div> Съешь же ещё этих мягких французских булок да выпей чаю. Эй, жлоб! Где туз? Прячь юных съёмщиц в шкаф. Друг мой эльф! Яшке б свёз птиц южных чащ! В чащах юга жил бы цитрус? Да, но фальшивый экземпляр! Широкая электрификация южных губерний даст мощный толчок подъёму сельского хозяйства. Шеф взъярён тчк щипцы с эхом гудбай Жюль.</div>
        `
    });
    ```

    ```warning md
    Обратите внимание, что после значения высоты обязательно нужно указывать знак подчеркивания. В противном случае высота окна фиксироваться не будет.
    ```

1. Модификатор «**eh=значение**» позволяет задать фиксированную высоту окна редактора кода.

    Значение высоты в этом случае задается в пикселях без указание единицы измерения. Например,

    ```text hideGutter
        ```javascript run_edit_[my-component.js]_eh=90_
        ODA({
            is: 'my-component',
            template: `
                <div>Съешь же ещё этих мягких французских булок да выпей чаю. Эй, жлоб! Где туз? Прячь юных съёмщиц в шкаф. Друг мой эльф! Яшке б свёз птиц южных чащ! В чащах юга жил бы цитрус? Да, но фальшивый экземпляр! Широкая электрификация южных губерний даст мощный толчок подъёму сельского хозяйства. Шеф взъярён тчк щипцы с эхом гудбай Жюль.</div>
            `
        });
        ```
    ```

    Если код в редакторе превысит указанную высоту, то с его правой стороны появится стандартная полоса прокрутки, с помощью которой можно будет просмотреть остальной, не уместившийся в окне код.

    Например,

    ```javascript run_edit_[my-component.js]_h=60_eh=90_
    ODA({
        is: 'my-component',
        template: `
            <div>Съешь же ещё этих мягких французских булок да выпей чаю. Эй, жлоб! Где туз? Прячь юных съёмщиц в шкаф. Друг мой эльф! Яшке б свёз птиц южных чащ! В чащах юга жил бы цитрус? Да, но фальшивый экземпляр! Широкая электрификация южных губерний даст мощный толчок подъёму сельского хозяйства. Шеф взъярён тчк щипцы с эхом гудбай Жюль.</div>
        `
    });
    ```

    Данный модификатор следует использовать тогда, когда код примера по высоте будет очень большим, так как по умолчанию высота редактора определяется автоматически по его содержимому, и в этих случаях она может оказаться неприемлемо большой.

    ```info md
    Обратите внимание, что после значения высоты необходимо указать знак подчеркивания. В противном случае высота окна фиксироваться не будет.
    ```

1. Модификатор «**console**» позволяет задать дополнительную кнопку для отображения окна с сообщениями, отправляемыми в консоль каждого отдельного примера.

    Например,

    ```text hideGutter
        ```javascript run_edit_[my-component.js]_console
        ODA({
            is: 'my-component',
            template: `
                <div>Чтобы увидеть консоль, нажмите на кнопку в правом верхнем углу редактора.</div>
            `,
            ready()) {
                console.log('Вывод в консоль');
            }
        });
        ```
    ```

    При нажатии на эту кнопку под редактором кода появится дополнительная область, в которой будут выводится все сообщения, отправляемые в пределах этого блока в консоль с помощью стандартного javascript-объекта «**console**».

    ```javascript run_edit_[my-component.js]_console
    ODA({
        is: 'my-component',
        template: `
            <div>Чтобы увидеть консоль, нажмите на кнопку в правом верхнем углу редактора.</div>
        `,
        ready() {
            console.log('Вывод в консоль');
        }

    });
    ```

    С содержимым этой области можно выполнять следующие действия:

    1. Очистить, нажав на кнопку «**clear**».
    1. Перезапустить пример, повторно выполнив его, нажав на кнопку «**refresh**».
    1. Закрыть окно консоли, нажав на кнопку «**close**».

    ```info hideGutter
    Все эти кнопки отображаются в верхнем правом углу области консоли только если она отрыта.
    ```

    Обратите внимание, что при использовании функции «**alert**» все ее сообщения будут перехватываться и перенаправляться в консоль текущего примера.

    Например,

    ```javascript run_edit_[my-component.js]_console
    ODA({
        is: 'my-component',
        template: `
            <div>Чтобы увидеть сообщение функции «alert», нажмите на кнопку консоли в правом верхнем углу редактора.</div>
        `,
        ready() {
            alert('Это сообщение от alert');
        }
    });
    ```

    Это сделано специально для того, чтобы при загрузке страницы сообщения не выводились одновременно в отдельных модальных окнах, требуя от пользователя их последовательного закрытия. После полной загрузки страницы пользователь с помощью функции «**alert**» сможет спокойно просмотреть все отправленные сообщения в консоли каждого отдельного примера.

1. Модификатор иконки «**имя-модификатора**» позволяет вывести дополнительную иконку на левой границе области редактора кода.

    Например, чтобы вывести иконку с изображением красного крестика, символизирующего наличие ошибки в коде, необходимо указать модификатор «**error**».

    ```text hideGutter
        ```javascript run_edit_[my-component.js]_error
        ODA({
            is: 'my-component',
            template: `
                <div>Модификатор иконки error</div>
            `,
        });
        ```
    ```

    В этом случае левая граница рамки будет подсвечена красным цветом, на ней также будет отображаться соответствующая иконка.

    ```javascript run_edit_[my-component.js]_error
    ODA({
        is: 'my-component',
        template: `
            <div>Модификатор иконки error</div>
        `,
    });
    ```

    Кроме модификатора «**error**» для вывода иконок можно использовать и другие модификаторы:

    1. «**info**» — отображает иконку в виде круга с символом «**i**» внутри.
    1. «**success**» — отображает иконку в виде квадрата с символом **«галочки»** внутри.
    1. «**warning**» — отображает желтую иконку с восклицательным знаком.
    1. «**help**» — отображает иконку с синим вопросительным знаком.
    1. «**like**» — отображает иконку с поднятым вверх большим пальцем.
    1. «**faq**» — отображает иконку с изображением текстовой выноски.

1. Модификатор  «**hideicon**» позволяет спрятать изображении иконки на левой границе редактора кода.

    Например,

    ```text hideGutter
        ```javascript run_edit_[my-component.js]_error_hideicon
        ODA({
            is: 'my-component',
            template: `
                <div>Модификатор hideicon</div>
            `,
        });
        ```
    ```

    В этом случае иконка с изображение красного крестика отображаться не будет, но сама левая граница будет подсвечена красным цветом.

    ```javascript run_edit_[my-component.js]_error_hideicon
    ODA({
        is: 'my-component',
        template: `
            <div>Модификатор hideicon</div>
        `,
    });
    ```

1. Модификатор  «**hideGutter**» позволяет спрятать линейку с автоматической нумерацией строк кода.

    Например,

    ```text hideGutter
        ```javascript run_edit_[my-component.js]_error_hideicon_hideGutter
        ODA({
            is: 'my-component',
            template: `
                <div>Модификатор hideGutter</div>
            `,
        });
        ```
    ```

    В этом случае графический элемент с автоматической нумерацией строк кода отображаться не будет.

    ```javascript run_edit_[my-component.js]_error_hideicon_hideGutter
    ODA({
        is: 'my-component',
        template: `
            <div>Модификатор hideGutter</div>
        `,
    });
    ```

<div style="position:relative;padding-bottom:48%; margin:10px">
    <iframe src="https://www.youtube.com/embed/fZxiwOQogx0?start=0" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen
    	style="position:absolute;width:100%;height:100%;"></iframe>
</div>

<div style="position:relative;padding-bottom:48%; margin:10px">
    <iframe src="https://www.youtube.com/embed/7RT95GF0xFc?start=0" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen
    	style="position:absolute;width:100%;height:100%;"></iframe>
</div>
