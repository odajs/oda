
Изменение контекста в процессе выполнения геттера не приводит к повторному запуску этого геттера, так как запоминаемое в кэше значение уже соответствует контексту.

Например:

```javascript_run_edit_[my-component.js]_h=46_
ODA({
    is: 'my-component',
    template: `
        <div>Счетчик из геттера: {{getterCount}}</div>
        <div>Счетчик из метода: {{methodCount()}}</div>
    `,
    $public: {
        count1: 0,
        count2: 0,
        getterCount: {
            get() {
                return ++this.count1;
            }
        }
    },
    methodCount() {
        return ++this.count2;
    }
});
```

В примере видно, что изменение счетчика **count1** в геттере **getterCount** не приводит к его повторному выполнению, поэтому счетчик **count1** инкрементируется только один раз при загрузке страницы. Для сравнения: в методе **methodCount** аналогичный инкремент счетчика **count2** приводит к рендерингу страницы, что в свою очередь приводит к выполнению метода и очередному инкременту счетчика **count2**. Таким образом, инкремент счетчика происходит автоматически с частотой рендеринга страницы.

```warning_md
С осторожностью используйте несколько геттеров для изменения значения одного и того же свойства. Это может привести к взаимному сбросу кэшей этих геттеров, и их непрерывному выполнению.
```

Например:

```javascript_run_edit_[my-component.js]_h=46_
ODA({
    is: 'my-component',
    template: `
        <div>Счетчик из геттера 1: {{getterCount1}}</div>
        <div>Счетчик из геттера 2: {{getterCount2}}</div>
    `,
    $public: {
        count: 0,
        getterCount1: {
            get() {
                return ++this.count;
            }
        }
    },
    get getterCount2() {
            return ++this.count;
    }
});
```

В примере изменение свойства **count** в геттере **getterCount1** сбрасывает кэш геттера **getterCount2**, что приводит к его выполнению. В этом геттере свойство **count** опять изменяется и сбрасывает кэш геттера **getterCount1**. Фактически такое использование свойства **count** отключает кэши обоих геттеров и приводит к их выполнению при каждом рендеринге страницы.

В коде геттера обязательно должно быть обращение к какому-либо свойству, которое сбрасывает кэш гетера, иначе геттер превращается в константу. Обращение к свойству не обязательно должно быть непосредственно в коде геттера, обращение может находиться в одном из вызываемых геттером методов.

Например:

```javascript_run_edit_[my-component.js]_h=46_
ODA({
    is: 'my-component',
    template: `
        <input ::value="change">
        <div>Время: {{getterTime}}</div>
    `,
    $public: {
        change: "Измени меня",
        getterTime: {
            get() {
                this.hiddenChange();
                var d = new Date();
                return d.toLocaleTimeString() + '.' + d.getMilliseconds();
            }
        }
    },
    hiddenChange() {
        this.change;
    }
});
```

В примере геттер **getterTime** не содержит в своем коде обращение к свойству **change**, но он вызывает метод **hiddenChange**, в котором такое обращение присутствует. Поэтому при любом изменении текста в строке ввода текущее время на странице будет обновляться.

```warning_md
Чтобы свойство начало управлять сбросом кэша геттера, необходимо при выполнении геттера обратиться к нему хотя бы один раз.
```

Например:

```javascript_run_edit_[my-component.js]_h=46_
ODA({
    is: 'my-component',
    template: `
        <button @tap="permission=!permission">Permit={{permission}}</button>
        <div>Время из геттера: {{getterTime}}</div>
    `,
    $public: {
        count: 0,
        permission: false,
        getterTime: {
            get() {
                if(this.permission) this.count;
                var d = new Date();
                return d.toLocaleTimeString() + '.' + d.getMilliseconds();
            }
        }
    },
    attached() {
        setInterval( ()=>{++this.count}, 1000);
    }
});
```

В примере сразу после загрузки страницы геттер **getterTime** выполняется один раз, и время на экране больше не обновляется. При первом выполнении геттера обращение к свойству **count** было заблокировано условным оператором. Нажмите на кнопку **Permit**, чтобы заставить геттер выполниться второй раз из-за изменения значения свойства **permission**. При этом в условном операторе произойдет обращение к свойству **count**. Теперь при каждом изменении счетчика **count** кэш геттера сбрасывается и происходит выполнение геттера, что видно по изменению времени на странице. Если повторно нажать на кнопку **Permit**, то условный оператор опять заблокирует обращение к свойству **count**, однако отсчет времени не прекратится, так как свойство **count** уже зарегистрировано для управления кэшем.
