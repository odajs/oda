**$next** — это метод, который позволяет вызвать любую функцию или метод через определенное количество кадров анимации.

Обычно запросы на выполнение кадров анимации в браузерах происходят 60 раз в секунду, но чаще всего это число совпадает с частотой обновления монитора. Из-за этого использование метода **$next** во многих случаях может оказаться более эффективным, чем задание фиксированной временной задержки, как это, например, происходит в методе **async**.

В любом компоненте метод **$next** объявлен следующим образом:

```javascript
 $next(handler, taсts = 0)
```

Ему передаются 2 параметра:

1. **handler** — вызываемая функция или метод.
1. **taсts** — количество кадров анимации, которое необходимо пропустить до вызова указанного метода или функции.

Например,

```javascript _run_edit_[my-component.js]
 ODA({
    is: 'my-component',
    template: `
        <button @tap="onTap">{{label}}</button>
    `,
    props: {
        label: 'Нажмите меня'
    },
    onTap() {
        this.$next(() => {this.label='Я выполняюсь через 60 тактов анимации'}, 60);
        this.$next(() => {this.label='Я выполняюсь через 120 тактов анимации'}, 120);
    }
});
```

В данном примере вызываются стрелочные функции через 60 и 120 тактов анимации соответственно. Временная задержка их вызовов будет составлять приблизительно 1 и 2 секунды.

Если с помощью метода **$next** необходимо вызвать не функцию, а метод какого-то компонента, то с помощью метода **bind** к нему обязательно нужно привязать контекст этого компонента.

Например,

```javascript _run_edit_[my-component.js]
 ODA({
    is: 'my-component',
    template: `
        <button @tap="onTap">{{label}}</button>
    `,
    props: {
        label: 'Нажмите меня'
    },
    up() {
        this.label = 'Я выполняюсь только через 60 тактов';
    },
    down() {
        this.label = 'Я выполняюсь только через 120 тактов';
    },
    onTap() {
        this.$next(this.up.bind(this), 60);
        this.$next(this.down.bind(this), 120);
    }
});
```

Если этого не сделать, то указатель **this** внутри вызываемого метода будет иметь неопределенное значение **undefined**.

Например,

```javascript error_run_edit_[my-component.js]_console
 ODA({
    is: 'my-component',
    template: `
        <button @tap="onTap">{{label}}</button>
    `,
    props: {
        label: 'Нажмите меня'
    },
    up() {
        this.label = 'Я выполняюсь только через 60 тактов';
    },
    down() {
        this.label = 'Я выполняюсь только через 120 тактов';
    },
    onTap() {
        this.$next(this.up, 60);
        this.$next(this.down.bind(this), 120);
    }
});
```

В данном примере произойдет ошибка при обращении к свойству **label** в методе **up**, так как указатель **this** внутри метода будет иметь неопределенное значение **undefined**. В результате этого сообщение «**Я выполняюсь только через 60 тактов**» не появится, а в консоли браузера будет выведено сообщение об ошибке.

Для того, чтобы явно не привязывать контекст компонента к методу, имена методов можно указывать просто в виде строки.

Например,

```javascript _run_edit_[my-component.js]
 ODA({
    is: 'my-component',
    template: `
        <button @tap="onTap">{{label}}</button>
    `,
    props: {
        label: 'Нажмите меня'
    },
    up() {
        this.label = 'Я выполняюсь только через 60 тактов';
    },
    down() {
        this.label = 'Я выполняюсь только через 120 тактов';
    },
    onTap() {
        this.$next('up', 60);
        this.$next('down', 120);
    }
});
```

В этом случае метод **$next** преобразует переданное ему имя метода в его вызов, присоединив к нему контекст текущего компонента автоматически.

Например, строка **'up'** будет заменена на вызов **this.up.bind(this)**, а строка **'down'** — на вызов **this.down.bind(this)**.

При вызове анонимной функции ее контекст будет также не определен, т.е. указатель **this** будет иметь неопределенное значение **undefined**.

Например,

```javascript error_run_edit_[my-component.js]_console
 ODA({
    is: 'my-component',
    template: `
        <button @tap="onTap">{{label}}</button>
    `,
    props: {
        label: 'Нажмите меня',
        count: 0
    },
    onTap() {
        this.$next(function() {this.label='Я выполняюсь только через 60 тактов'}, 60);
        this.$next(function() {this.label='Я выполняюсь только через 120 тактов'}.bind(this), 120);
    }
});
```

Из-за этого при вызове первой функции возникнет ошибка, т.е. сообщение «**Я выполняюсь только через 60 тактов**» не появится. У второй функции контекст компонента привязан с помощью метода **bind**. По этой причине никакая ошибка в этой функции возникать не будет. Использовать имя функции для автоматической привязки к ней контекста в
этом случае не получится, так как эти функции анонимные, т.е. у них не имеют имен.

Если при вызове метода **$next** задать нулевую задержку, то указанные методы или функции будут вызываться сразу же со следующим тактом анимации.

Например,

```javascript _run_edit_[my-component.js]
 ODA({
    is: 'my-component',
    template: `
        <button @tap="onTap">{{label}}</button>
    `,
    props: {
        label: 'Нажмите меня'
    },
    up() {
        this.label = 'Я выполняюсь практически сразу';
    },
    down() {
        this.label += ' Я тоже выполняюсь сразу же';
    },
    onTap() {
        this.$next('up', 0);
        this.$next('down', 0);
    }
});
```

Если у метода **$next** не указать явно задержку во втором параметре, то по умолчанию она будет принята равной нулю.

Например,

```javascript _run_edit_[my-component.js]
 ODA({
    is: 'my-component',
    template: `
        <button @tap="onTap">{{label}}</button>
    `,
    props: {
        label: 'Нажмите меня'
    },
    up() {
        this.label = 'Я выполняюсь практически сразу';
    },
    down() {
        this.label += ' Я тоже выполняюсь сразу же';
    },
    onTap() {
        this.$next('up');
        this.$next('down');
    }
});
```

В результате этого данный пример будет работать абсолютно аналогично предыдущему, т.е. оба метода будут выполняться последовательно друг за другом сразу на следующем такте анимации.

<div style="position:relative;padding-bottom:48%; margin:10px">
    <iframe src="https://www.youtube.com/embed/8_ZF-NPBK4o?start=0" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen
    	style="position:absolute;width:100%;height:100%;"></iframe>
</div>
