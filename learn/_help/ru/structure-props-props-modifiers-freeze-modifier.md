Модификатор **freeze** используется для изменения механизма обработки реактивности структурных свойств компонента.

По умолчанию все свойства компонента автоматически оборачиваются в специальный объект **Proxy**, который перехватывает все выполняемые операции с ними, включая операции чтения и записи. В обработчиках этих операции реализуется механизм реактивности, который заставляет другие свойства автоматически изменять свои значения, при изменении значения тех свойств, от которых они зависят.

В результате этого изменение значения одного свойства автоматически будет приводить к изменению значения всех зависящих от него свойств так, как это показано в следующем примере:

```javascript _run_edit_console_[my-component.js]
 ODA({
    is: 'my-component',
    template: `
        <div>Число {{count}} – {{text}}</div>
        <button @tap="onTap">Нажми на меня</button>
    `,
    $public: {
        count: 0,
        text: {
            get() {
                return this.count & 1 ? "нечетное число" : "четное число";
            }
        }
    },
    onTap() {
        this.count++;
    }
});
```

Здесь каждое нажатие на кнопку **button** будет изменять значение свойства **count**, что, благодаря механизму реактивности, будет автоматически приводить к изменению свойства **text**, которое от него зависит. Кроме этого, изменения свойств **count** и **text** будут автоматически приводить к изменению интерполяционных подстановок **Mustache**: {{count}} и {{text}}, которые используются внутри элемента **div**.

Данный механизм реактивности сохраняется и для элементов структурных свойств, в качестве которых могут выступать как элементы массивов, так и свойства любых других объектов.

Например:

```javascript _run_edit_console_[my-component.js]
 ODA({
    is: 'my-component',
    template: `
        <div>Число {{items[0]}} – {{text}}</div>
        <button @tap="onTap">Нажми на меня</button>
    `,
    $public: {
        items: [1, 2, 3],
        text: {
            reactive: true,
            get() {
                return this.items[0] & 1 ? "нечетное число" : "четное число";
            }
        }
    },
    onTap() {
        this.items[0]++;
    }
});
```

В этом примере каждое нажатие на кнопку **button** приводит к изменению значения первого элемента массива, заданного свойством **items**. От этого значения зависит свойство **text**, которое автоматически изменяется благодаря механизму реактивности. Все эти изменения отражаются с помощью интерполяционных подстановок **Mustache**: {{items[0]}} и {{text}}, указанных внутри элемента **div**.

Аналогичная ситуация будет происходить, если вместо элементов массива использовать свойства объектов.

Например,

```javascript _run_edit_console_[my-component.js]
 ODA({
    is: 'my-component',
    template: `
        <div>Число {{items.a}} – {{text}}</div>
        <button @tap="onTap">Нажми на меня</button>
    `,
    $public: {
        items: {a: 1, b: 2, c: 3},
        text: {
            get() {
                return this.items.a & 1 ? "нечетное число" : "четное число";
            }
        }
    },
    onTap() {
        this.items.a++;
    }
});
```

В отличие от предыдущего примера, здесь свойство **items** является не массивом, а объектом, заданным в литеральной форме. Нажатие на кнопку **button** будет приводить к изменению его первого свойства с именем **a**, от значения которого зависит свойство **text**. В результате этого изменение значение свойства **a** объекта **items** будет приводить к изменению значения свойства **text** компонента и, соответственно, к изменению содержимого элемента **div**.

Реализация такой возможности требует, чтобы каждое структурное свойство было обернуто в свой собственный объект **Proxy**, который отслеживал бы изменения всех вложенных в данный объект свойств или значений элементов в массивах. Это может привести к значительным затратам машинного времени при решении реальных задач, когда в массивах будет располагаться большое количество элементов или когда у объектов будет сложная структура вложенных свойств. В этом случае механизм реактивности можно заблокировать. Для этого достаточно у структурного свойства указать специальный модификатор **freeze** со значением **true**.

Например,

```javascript _run_edit_console_[my-component.js]
 ODA({
    is: 'my-component',
    template: `
        <div>Число {{items.a}} – {{text}}</div>
        <button @tap="onTap">Нажми на меня</button>
    `,
    $public: {
        items: {
            $freeze: true,
            $def: {a: 1, b: 2, c: 3}
        },
        text: {
            get() {
                return this.items.a & 1 ? "нечетное число" : "четное число";
            }
        }
    },
    onTap() {
       this.items.a++;
    },
});
```

В этом случае, механизм реактивности для элементов структурного свойства будет отключен на любом уровне вложенности. Фактически модификатор **freeze** запрещает оборачивать данное свойство в **Proxy**-объект. В результате этого нажатие на кнопку **button** не будет приводить ни к каким внешним изменениям, несмотря на то, что само свойство **a** объекта **items** будет изменяться в обычном режиме.

Следует отметить, что директива **freeze** не отключает реактивность у самого свойства, в котором она указана, реактивность отключается только у вложенных в него элементов.

Например,

```javascript _run_edit_console_[my-component.js]
 ODA({
    is: 'my-component',
    template: `
        <div>Исходный объект: {{JSON.stringify(items)}}</div>
        <button @tap="onTap">Нажми на меня</button>
        <div>Число {{items.a}} – {{text}}</div>
    `,
    $public: {
        items: {
            $freeze: true,
            $def: {a: 1, b: 2, c: 3}
        },
        text: {
            get() {
                return this.items.a & 1 ? "нечетное число" : "четное число";
            }
        }
    },
    onTap() {
        let max = 10;
        let min = 1;
        this.items = new Object();
        this.items.a = Math.floor(Math.random() * (max - min + 1)) + min;
        this.items.b = Math.floor(Math.random() * (max - min + 1)) + min;
        this.items.c = Math.floor(Math.random() * (max - min + 1)) + min;
    }
});
```

В данном примере при каждом нажатии на кнопку **button** будет создаваться новый объект, в результате чего будет изменяться значение самого свойства **items**. Механизм реактивности отследит эти изменения для самого объекта и они будет отображены в элементах **div**.

В случае отключения реактивности вложенные элементы объектов продолжают изменяться, но заметить это возможно только при изменение других свойств, когда компонент будет перерисовываться заново с уже измененными значениями свойств c отключенной реактивностью.

Например,

```javascript _run_edit_console_[my-component.js]
 ODA({
    is: 'my-component',
    template: `
        <div>Число {{items.a}} – {{text}}</div>
        <button @tap="onTap">Нажми на меня</button>
    `,
    $public: {
        items: {
            $freeze: true,
            $def: {a: 1, b: 2, c: 3}
        },
        text: {
            get() {
                return this.items.a & 1 ? "нечетное число" : "четное число";
            }
        }
    },
    onTap() {
       this.items.a++;
       this.text = "Новое значение свойства";
    },
});
```

На неструктурные свойства модификатор **freeze** никакого влияния не оказывает. Для них реактивность будет работать всегда.

Например,

```javascript _run_edit_console_[my-component.js]
 ODA({
    is: 'my-component',
    template: `
        <div>Число {{count}} – {{text}}</div>
        <button @tap="onTap">Нажми на меня</button>
    `,
    $public: {
        count: {
            $freeze: true,
            $def: 0
        },
        text: {
            $freeze: true,
            get() {
                return this.count & 1 ? "нечетное число" : "четное число";
            }
        }
    },
    onTap() {
        this.count++;
    }
});
```

По этой причине модификатор **freeze** следует использовать только для структурных свойств от элементов и свойств которых никакие другие свойства не зависят. В этом случае блокирование механизма реактивности приведет к повышению скорости обработки данных при большом количестве элементов в массивах или при сложной иерархической структуре свойств объектов.

<div style="position:relative;padding-bottom:48%; margin:10px">
    <iframe src="https://www.youtube.com/embed/E4KS8qnFuT0?start=0" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen
    	style="position:absolute;width:100%;height:100%;"></iframe>
</div>
