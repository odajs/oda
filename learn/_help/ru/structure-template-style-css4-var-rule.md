Пользовательские CSS-свойства имеют определенные правила задания, о которых следует поговорить отдельно.

При выборе имени CSS-свойства желательно использовать kebab-нотацию. В этом случае CSS-свойства будут доступны в любых объектах и функциях.

```info_md
Пользовательские CSS-свойства не отображаются в объекте **CSSStyleDeclaration**, если они записаны в **camel-нотации**, поскольку их имена могут содержать как строчные, так и прописные буквы. Однако они будут доступны по собственному имени через **getPropertyValue()** и т.д.
```

Кроме этого, различные сериализации до сих пор приводят имена пользовательских свойств к нижнему регистру, хотя по спецификации они должны сохраняться в том виде, в котором они были заданы пользователем.

```warning_md
Обратите внимание, что подстановка **var()** происходит на уровне [CSS-токенов](https://www.w3.org/TR/css-syntax-3/#token-diagrams), а не на текстовом уровне. Поэтому вы не можете использовать функцию **var()** для формирования имени или части значения CSS-объявления.
```

Например, следующие записи будут ошибочны:

```html_error_md
span {
    --my-margin: margin-top;
    var(--my-margin): 20px;
}
```

```html_error_md
span {
    --gap: 20;
    margin-top: var(--gap)px;
}
```

Сформированные здесь выражения не эквивалентны **margin-top: 20px;**. В первом случае функция **var()** формирует не значение, а имя CSS-объявления, а во втором случае она формирует не всё значение целиком, а только его часть. Все эти варианты изначально будут признаны недействительными.

Функцию **var()** также можно использовать в вычисляемом выражении.

```html_like_md
span {
    --gap: 20;
    margin-top: calc(var(--gap) * 1px);
}
```

Здесь не будет никакой ошибки, т.к. функция будет возвращать значение 20, а не строку.

Если функция **var()** вернет гарантированно недействительное значение, то CSS-правило не будет применяться к элементам.

Однако функция **var()** может быть изначально записана правильно, но ее возвращаемое значение может оказаться недействительным в контексте определенного CSS-объявления.

Например:

```html_error_md
span {
    --gap: 20px;
    background-color: var(--gap);
}
```

Очевидно, что **background-color: 20px** является ошибкой, и это CSS-правило применяться не будет.

```html_warning_md
Такая ситуация может привести к возникновению непредвиденных ошибок, так как обработка CSS-объявлений с CSS-свойствами происходит в несколько ином порядке.
```

В начале значение функции **var()** не подставляется, а CSS-объявление проверяется в том виде, в котором оно записано. В результате этого оно может изначально оказаться валидным, однако после подстановки оно может стать недействительным. В этом случае CSS-объявление к HTML-элементам, для которых оно указывалось, применяться не будет.

Например:

```javascript_error_run_edit_line[my-component.js]
ODA({
    is: 'my-component',
    template: `
        <style>
            :host {
                --my-color: 20px;
            }
            span {
                background-color: red;
                background-color: var(--my-color);
            }
        </style>
        <span>Теневой span</span>
    `
});
```

В этом примере при проверке второго CSS-объявления не будет обнаружено никаких ошибок, и первое объявление будет отброшено. Однако после подстановки каскадной переменной второе CSS-правило окажется гарантированно недействительным. В результате этого элемент **span** не будет отображаться на красном фоне, так как первое валидное правило уже было отклонено из-за дублирования вторым изначально валидным CSS-объявлением.

Если бы ошибка была обнаружена сразу, то невалидное CSS-объявления было бы отброшено, и предыдущее правильное объявление осталось бы в таблице стилей.

```javascript_run_edit_line[my-component.js]
ODA({
    is: 'my-component',
    template: `
        <style>
            span {
                background-color: red;
                background-color:  20px;
            }
        </style>
        <span>Теневой span</span>
    `
});
```

В некоторых случаях само CSS-свойство может оказаться гарантированно недействительным. В светлом дереве, например, оно может быть просто не задано.

Например:

```javascript_error_run_edit_line[my-component.js]
ODA({
    is: 'my-component',
    template: `
        <style>
            span {
                background-color: var(--my-color);
            }
        </style>
        <span>Теневой span</span>
    `
});
```

В этом случае элемент **span** останется без фона, так как CSS-свойство **--my-color** нигде не было определено.

Во избежание подобных ситуаций, внутри компонента можно предусмотреть запасное значение (**fallback**), задав его в качестве второго необязательного параметра у функции **var()**. Указанное в нем значение будет использоваться тогда, когда первый параметр функции окажется изначально недействительным.

Например:

```javascript_error_run_edit_line[my-component.js]
ODA({
    is: 'my-component',
    template: `
        <style>
            span {
                background-color: var(--my-color, lime);
            }
        </style>
        <span>Теневой span</span>
    `
});
```

В этом примере фон у элемента **span** будет задан с использовании запасного значения **lime**.

Если указанный первый параметр окажется валидным, то функция **var()** вернет именно его, а не запасное значение.

```javascript_error_run_edit_line[my-component.js]
ODA({
    is: 'my-component',
    template: `
        <style>
            :host {
                --my-color: yellow;
            }
            span {
                background-color: var(--my-color, lime);
            }
        </style>
        <span>Теневой span</span>
    `
});
```

```html_warning_md
Запасное значение используется только тогда, когда невалидным является само CSS-свойство, а не его значение.
```

Если значение CSS-свойства будет гарантированно недействительным, то запасное значение для исправления этой ошибки применяться не будет.

```javascript_error_run_edit_line[my-component.js]
ODA({
    is: 'my-component',
    template: `
        <style>
            :host {
                --my-color: 20px;
            }
            span {
                background-color: var(--my-color, lime);
            }
        </style>
        <span>Теневой span</span>
    `
});
```

Здесь CSS-свойство **--my-color** существует, но то, что оно имеет неправильное значение в текущем контексте, не будет считаться ошибкой. В результате этого запасное значение **lime** использоваться не будет. Свойство останется недействительным.

<div style="position:relative;padding-bottom:48%; margin:10px">
    <iframe src="https://www.youtube.com/embed/nhCIABcK5Js?start=0" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen 
    	style="position:absolute;width:100%;height:100%;"></iframe>
</div>
