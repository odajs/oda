**Сеттер** (Setter) — это метод, который объявляется внутри свойства и вызывается автоматически после изменения его значения.

Сеттер задается только в расширенной форме объявления свойства, как функция с предопределенным именем **set**. По сути дела он является хуком, который вызывается сразу после изменения значения свойства. В нем можно предусмотреть дополнительные действия, которые должны быть выполнены после присвоения значения свойству.

Например:

```javascript _run_edit_console_[my-component.js]
 ODA({
    is: 'my-component',
    template: `
        <button @tap="_onTap">{{text}}</button>
    `,
    $public: {
        _count: {
            $def: 0,
            set(n, o) {
                this.text = n + (n & 1 ? " - нечетное число" : " - четное число");
                alert("Новое значение: " + n + " Старое значение: " + o);
            }
        },
        text: "Кнопка",
    },
    _onTap() {
        this._count++;
    }
});
```

В данном примере счетчик **\_count** будет увеличиваться на единицу при каждом нажатии на кнопку. Сразу после его изменения вызывается хук **set**, которому передаются два параметра: новое значение свойства (n) и старое (o). В теле сеттера можно изменить значение другого свойства **text**. Это изменение будет динамически отражено в надписи на кнопке, которое связано со свойством **text** с помощью директивы интерполяционной подстановки **{{ }}**.

```info_md
Во время создания компонента при присвоении начального значения сеттер не вызывается. По этой причине надпись на кнопке остается со значением по умолчанию до первого изменения счетчика **_count**.
```

```error_md
Крайне нежелательно в сеттере присваивать значение свойству, в котором этот сеттер был объявлен. При определенных обстоятельствах это может привести к возникновению бесконечной рекурсии, когда сеттер будет вызывать самого себя до бесконечности.
```

```javascript _error_run_edit_console_[my-component.js]
 ODA({
    is: 'my-component',
    template: `
        <button @tap="_onTap">{{text}}</button>
    `,
    $public: {
        _count: {
            $def: 0,
            set(n, o) {
                this._count++;
                alert("Новое значение: " + n + " Старое значение: " + o);
            }
        },
        text: "Не стоит нажимать на эту кнопку",

    },
    _onTap() {
        this._count++;
    }
});
```

При нажатии на кнопку сеттер будет менять значение своего свойства **_count**. Поэтому он будет сам вызывать себя до переполнения стека. В этом можно убедиться, открыв консоль в инструментах разработчика браузера.

Изменять значение свойства, у которого задан сеттер, можно только вне его сеттера.

Например:

```javascript _run_edit_console_[my-component.js]
 ODA({
    is: 'my-component',
    template: `
        <button @tap="_onTap">{{text}}</button>
    `,
    $public: {
        _count: {
            $def: 0,
            set(n, o) {
                this.text++;
                alert("Новое значение: " + n + " Старое значение: " + o);
            }
        },
        text: {
            $def: 0,
            set(n, o) {
                alert("Новое значение: " + n + " Старое значение: " + o);
            }
        }
    },
    _onTap() {
        this._count++;
    }
});
```

Однако стоит избегать взаимного изменения двух свойств внутри их сеттеров.

```javascript _error_run_edit_console_[my-component.js]
 ODA({
    is: 'my-component',
    template: `
        <button @tap="_onTap">{{text}}</button>
    `,
    $public: {
        _count: {
            $def: 0,
            set(n, o) {
                this.text++;
                alert("Новое значение: " + n + " Старое значение: " + o);
            }
        },
        text: {
            $def: 0,
            set(n, o) {
                this._count++;
                alert("Новое значение: " + n + " Старое значение: " + o);
            }
        }
    },
    _onTap() {
        this._count++;
    }
});
```

Эта ситуация приводит к возникновению бесконечной рекурсии. Однако фреймворк умеет отслеживать ее автоматически и останавливает бесконечный цикл взаимных изменений после определенного количества шагов. По этой причине переполнение стека в этом примере не происходит, но значение счетчика будет формироваться неправильно. Оно будет увеличиваться не на единицу, как ожидалось, а на определенное значение, через которое цикл бесконечных изменений будет автоматически остановлен.

<div style="position:relative;padding-bottom:48%; margin:10px">
    <iframe src="https://www.youtube.com/embed/P9ykMjS3LUo?start=0" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen
    	style="position:absolute;width:100%;height:100%;"></iframe>
</div>

