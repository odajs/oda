Директива **~props** используется для динамического связывания свойств компонента с атрибутами HTML-элемента, в котором эта директива указана.

Связываемые свойства должны быть сгруппированы в одном объекте, который указывается как значение директивы. Директива создает в HTML-элементе из каждого свойства одноименный атрибут. Значение свойства становится значением этого атрибута.

Например,

```javascript_run_edit_[my-component.js]
ODA({
    is: 'my-component',
    template: `
        <input ~props="attr">
    `,
    attr: {
        type: 'range',
        min: 0,
        max: 100,
        step: 50
    }
});
```

В данном примере все атрибуты тега **input** заданы с помощью директивы. Если открыть инструменты разработчика в браузере, то можно убедиться, что из объекта **attr** в тег **input** перенесены все свойства.

```html
<my-component>
    #shadow-root (closed)
        <input type="range" min="0" max="100" step="50">
</my-component>
```

```info_md
Директива **~props** обеспечивает только однонаправленную связь от свойств компонента к атрибутам элемента. Изменения значений атрибутов в процессе функционирования элемента в свойства компонента не передаются.
```

Например,

```javascript_run_edit_[my-component.js]
ODA({
    is: 'my-component',
    template: `
        <input ~props="attr">
        <span>value: {{attr.value}}</span>
    `,
    attr: {
        type: 'range',
        min:0,
        max:100,
        step: 50,
        value: 0
    }
});
```

Данный пример аналогичен предыдущему, добавлено только свойство **value**, в котором хранится введенное пользователем значение, и вывод этого значения на экран. Подвигайте ползунок и убедитесь, что значение свойства **value** в объекте **attr** не изменяется.

С помощью директивы можно добавлять в HTML-элементы нестандартные атрибуты. Например, через такие атрибуты можно передавать параметры вложенным компонентам, или можно использовать их в CSS-селекторах.

Например,

```javascript_run_edit_[my-component.js]
ODA({
    is: 'my-component',
    imports: '@oda/button',
    template: `
        <style>
            oda-button[color="colorNumber_1"] {
                color: red;
            }
        </style>
        <oda-button ~props="attr">Кнопка</oda-button>
    `,
    attr: {
        color: 'colorNumber_1',
        icon: 'icons:android'
    }
});
```

В данном примере с помощью директивы и связанного с ней объекта **attr** настраивается вид компонента **oda-button**. Имя свойства **icon** совпадает с именем параметра компонента, в котором указывается название иконки, отображаемой на кнопке. А с помощью свойства **color** задается дополнительный селектор, связывающий компонент с CSS-правилом, определяющим красный цвет надписи на кнопке.

При создании атрибутов директива **~props** автоматически преобразует имена свойств из верблюжьей нотации (Camel case) в шашлычную (Kebab case). Такой подход позволяет создавать атрибуты, имена которых содержат дефис.

Например,

```javascript_run_edit_[my-component.js]
ODA({
    is: 'my-component',
    template: `
        <div ~props="attr">Атрибут с дефисом</div>
    `,
    attr: {
        myAttribute: 'Мой атрибут'
    }
});
```

В данном примере имя свойства **myAttribute** преобразовано в имя атрибута **my-attribute**, т.е. из верблюжьей нотации в шашлычную. В этом можно убедиться, открыв инструменты разработчика в браузере.

```html
<my-component>
    #shadow-root (closed)
        <div my-attribute="Мой атрибут">Атрибут с дефисом</div>
</my-component>
```

Также создать атрибут с дефисом можно, если имя свойства изначально записать с дефисом, как в атрибуте, и поместить в одинарные или двойные кавычки.

Например,

```javascript_run_edit_[my-component.js]
ODA({
    is: 'my-component',
    imports: '@oda/icon',
    template: `
        <div ~props="attr">Атрибут с дефисом</div>
    `,
    attr: {
        'my-attribute': 'Мой атрибут'
    }
});
```

В данный пример аналогичен предыдущему, только имя свойства сразу записано в шашлычной нотации и помещено в кавычки.

Значения атрибутов, устанавливаемых директивой **~props**, имеют приоритет над значениями атрибутов непосредственно указанных в теге HTML-элемента.

Например,

```javascript_run_edit_[my-component.js]
ODA({
    is: 'my-component',
    template: `
        <input ~props="attr" value="Текст из атрибута">
    `,
    attr: {
        value: 'Текст из директивы'
    }
});
```

В данном примере в элементе **input** атрибут **value** явно указан в теге. Однако, как видно по результату выполнения примера, его значение было переопределено директивой.

Значения атрибутов, задаваемые операцией биндинга, имеют приоритет над значениями атрибутов, устанавливаемых директивой **~props**.

Например,

```javascript_run_edit_[my-component.js]
ODA({
    is: 'my-component',
    template: `
        <input ~props="attr" :value="'Текст из операции биндинга'">
    `,
    attr: {
        value: 'Текст из директивы'
    }
});
```

В данном примере в элементе **input** использована операции биндинга для присвоения значения атрибуту **value**. Как видно по результату выполнения примера, значение устанавливаемое директивой было проигнорировано.

Директиву **~props** можно использовать совместно с директивой **~for**. В этом случае объекты с атрибутами для создаваемых HTML-элементов должны быть объединены в один массив.

Например,

```javascript_run_edit_[my-component.js]
ODA({
    is: 'my-component',
    template: `
        <input ~for="attr" ~props="$for.item">
    `,
    attr: [
        {type: 'text', placeholder: 'Введите значение'},
        {type: 'checkbox', checked: true },
        {type: 'range', max: 100, value: 25 },
        {type: 'button', value: 'Кнопка', style: 'background: yellow' }
    ]
});
```

В этом примере шаблон компонента содержит HTML-элемент **input**, в котором указаны директивы **~for** и **~props**. Первая директива создает четыре элемента **input**, а вторая добавляет в каждый элемент свои собственные атрибуты, определяющие его функциональность.

Механизм реактивности в директиве **~props** отличается от механизма, поддерживаемого другими директивами. Изменение значений свойств в связанном с ней объекте не приводит к автоматическому выполнению директивы.

Например,

```javascript_run_edit_error_[my-component.js]
ODA({
    is: 'my-component',
    template: `
        <input type="button" ~props="attr" @tap="onTap">
        <span>value: {{attr.value}}</span>
    `,
    attr: {
        value: 'Нажми меня',
    },
    onTap() {
        this.attr.value = this.attr.value=='Щелкни по мне' ? 'Нажми меня' : 'Щелкни по мне';
    }
});
```

В данном примере при нажатии на кнопку меняется значение свойства **value** в объекте **attr**, который связан с директивой **~props**. Для контроля новое значение выводится на экран. Это свойство задает надпись на кнопке. Однако видно, что надпись не меняется, значит, механизм реактивности не запускает директиву.

Что заработал механизм реактивности необходимо передать директиве совершенно новый объект, отличающийся от предыдущего ссылкой.

Например,

```javascript_run_edit_[my-component.js]
ODA({
    is: 'my-component',
    template: `
        <input type="button" ~props="attr" @tap="onTap">
        <span>value: {{attr.value}}</span>
    `,
    attr: {
        value: 'Нажми меня',
    },
    onTap() {
        let v = this.attr.value=='Щелкни по мне' ? 'Нажми меня' : 'Щелкни по мне';
        this.attr = {};
        this.attr.value = v;
    }
});
```

Данный пример аналогичен предыдущему, только теперь для изменения значения свойства **value** создается новый объект, а затем в этом объекте создается свойство **value** с новым значением. Этот новый объект передается директиве через указатель **attr**.

В своей работе директива взаимодействует с DOM-объектом HTML-элемента. Для каждого добавляемого атрибута директива проверяет наличие соответствующего ему свойства в DOM-объекте. Если такое свойство существует, то директива присваивает ему новое значение, а браузер сам создает для него атрибут в HTML-элементе, если сочтет это необходимым. Если такое свойство отсутствует, то тогда директива создает атрибут в HTML-элементе с помощью метода **setAttribute** DOM-объекта.

Рассмотрим три возможных варианта взаимодействия директивы с DOM-объектом.

Пример 1,

```javascript_run_edit_[my-component.js]
ODA({
    is: 'my-component',
    template: `
        <input id="i1" placeholder="с ~props" ~props="attr" >
        <span>Имеет свойство type: {{'type' in $('#i1')}} — Имеет атрибут type: {{$('#i1').hasAttribute('type')}}</span>
        <br>
        <input id="i2" placeholder="без ~props">
        <span>Имеет свойство type: {{'type' in $('#i2')}} — Имеет атрибут type: {{$('#i2').hasAttribute('type')}}</span>
    `,
    attr: {
        type: 'text'
    }
});
```

В данном примере директива создает атрибут **type** в элементе **input**. Для контроля информация о наличии одноименного свойства и атрибута в DOM-объекте элемента выводится на экран. Для сравнения в пример включен второй элемент **input** без указанного атрибута и без директивы. Можно видеть, что свойство **type** изначально присутствует в DOM-объекте, но одноименный атрибут создан только у элемента с директивой **~props**.

Примечание — В примере используется метод **$** (см. раздел методы компонента) для получения указателя на DOM-объект элемента **input**.

Пример 2,

```javascript_run_edit_[my-component.js]
ODA({
    is: 'my-component',
    template: `
        <input id="i1" ~props="attr" >
        <span>Имеет свойство value: {{'value' in $('#i1')}} — Имеет атрибут value: {{$('#i1').hasAttribute('value')}}</span>
        <br>
        <input id="i2" placeholder="без ~props">
        <span>Имеет свойство value: {{'value' in $('#i2')}} — Имеет атрибут value: {{$('#i2').hasAttribute('value')}}</span>
    `,
    attr: {
        value: 'с ~props'
    }
});
```

Данный пример аналогичен предыдущему, только вместо атрибута **type** директива пытается создать атрибут **value**. Можно видеть, что свойство **value** изначально присутствует в DOM-объекте. В элементе **input** оно предназначено для временного хранения значений введенных пользователем, поэтому браузер не создает одноименный атрибут, хотя и использует значение свойства при отображении текста в элементе.

Пример 3,

```javascript_run_edit_[my-component.js]
ODA({
    is: 'my-component',
    template: `
        <input id="i1" placeholder="с ~props" ~props="attr" >
        <span>Имеет свойство nick: {{'nick' in $('#i1')}} — Имеет атрибут nick: {{$('#i1').hasAttribute('nick')}}</span>
        <br>
        <input id="i2" placeholder="без ~props">
        <span>Имеет свойство nick: {{'nick' in $('#i2')}} — Имеет атрибут nick: {{$('#i2').hasAttribute('nick')}}</span>
    `,
    attr: {
        nick: 'Строка ввода'
    }
});
```

Данный пример аналогичен предыдущему, только вместо атрибута **value** директива создает атрибут **nick**. Можно видеть, что свойство **nick** изначально отсутствует в DOM-объекте, но директива всё равно создает одноименный атрибут.

```warning_md
Внимательно выбирайте имена атрибутов создаваемых директивой **~props**. Директива не отличает свойства DOM-объекта, соответствующие атрибутам элемента, от других его свойств и может изменить их значение. Это может неожиданным образом повлиять на отображение HTML-элемента.
```

Например,

```javascript_run_edit_error_[my-component.js]
ODA({
    is: 'my-component',
    template: `
        <div ~props="attr">Исходный текст</div>
    `,
    attr: {
        innerText: 'Текст из директивы ~props'
    }
});
```

В данном примере директива пытается создать атрибут **inner-text** в элементе **div**, но поскольку DOM-объект содержит свойство **innerText**, вместо создания атрибута меняется содержимое текстового узла элемента.

<div style="position:relative;padding-bottom:48%; margin:10px">
    <iframe src="https://www.youtube.com/embed/JU-T3ZRUhqM?start=0" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen
    	style="position:absolute;width:100%;height:100%;"></iframe>
</div>
