Директива **~props** используется для динамического связывания свойств компонента с атрибутами HTML-элемента, в котором она указана. Также с помощью директивы можно передавать параметры во вложенные компоненты.

В отличие от биндинга, связывающего одно свойство компонента с одним атрибутом HTML-элемента и требующего явно указывать все связываемые пары, директива **~props** привязывает к элементу сразу группу свойств. Эти свойства должны быть сгруппированы в одном объекте, который указывается как значение директивы. Директива создает в HTML-элементе из каждого свойства одноименный атрибут. Значение свойства становится значением этого атрибута.

Например,

```javascript_run_edit_[my-component.js]
ODA({
    is: 'my-component',
    template: `
        <input ~props="attr">
    `,
    attr: {
        type: 'range',
        min: 0,
        max: 100,
        step: 50
    }
});
```

В данном примере все атрибуты тега **input** заданы в объекте **attr**, связанном с директивой. Если открыть инструменты разработчика в браузере, то можно убедиться, что из объекта **attr** в тег **input** перенесены все свойства.

```html
<my-component>
    #shadow-root (closed)
        <input type="range" min="0" max="100" step="50">
</my-component>
```

```info_md
Можно использовать сокращенный синтаксис директивы **~props**, состоящий только из ее имени. В этом случае компонент должен содержать объект с именем **props**, который автоматически будет привязан к директиве.
```

Например,

```javascript_run_edit_[my-component.js]
ODA({
    is: 'my-component',
    template: `
        <input ~props>
    `,
    props: {
        type: 'range',
        min: 0,
        max: 100,
        step: 50
    }
});
```

Данный пример аналогичен предыдущему, только директива указана без привязанного объекта, а имя объекта с атрибутами изменено с **attr** на **props**.

```info_md
Директива **~props** обеспечивает только однонаправленную связь от свойств компонента к атрибутам элемента. Изменения значений атрибутов в процессе функционирования элемента в свойства компонента не передаются.
```

Например,

```javascript_run_edit_[my-component.js]
ODA({
    is: 'my-component',
    template: `
        <input ~props="attr">
        <span>value: {{attr.value}}</span>
    `,
    attr: {
        type: 'range',
        min:0,
        max:100,
        step: 50,
        value: 0
    }
});
```

Данный пример аналогичен предыдущему, добавлено только свойство **value**, в котором хранится введенное пользователем значение, и вывод этого значения на экран. Подвигайте ползунок и убедитесь, что значение свойства **value** в объекте **attr** не изменяется.

С помощью директивы можно добавлять в HTML-элементы нестандартные атрибуты. Например, через такие атрибуты можно передавать параметры вложенным компонентам, или можно использовать их в CSS-селекторах.

Например,

```javascript_run_edit_[my-component.js]
ODA({
    is: 'my-component',
    imports: '@oda/button',
    template: `
        <style>
            oda-button[color="colorNumber_1"] {
                color: red;
            }
        </style>
        <oda-button ~props="attr">Кнопка</oda-button>
    `,
    attr: {
        icon: 'icons:android',
        color: 'colorNumber_1'
    }
});
```

В данном примере с помощью директивы и связанного с ней объекта **attr** настраивается вид компонента **oda-button**. Имя свойства **icon** совпадает с именем параметра компонента, в котором указывается название иконки, отображаемой на кнопке. А с помощью свойства **color** задается дополнительный селектор, связывающий компонент с CSS-правилом, определяющим красный цвет надписи на кнопке.

При создании атрибутов директива **~props** автоматически преобразует имена свойств из верблюжьей нотации (Camel case) в шашлычную (Kebab case). Такой подход позволяет создавать атрибуты, имена которых содержат дефис.

Например,

```javascript_run_edit_[my-component.js]
ODA({
    is: 'my-component',
    template: `
        <div ~props="attr">Атрибут с дефисом</div>
    `,
    attr: {
        myAttribute: 'Мой атрибут'
    }
});
```

В данном примере имя свойства **myAttribute** преобразовано в имя атрибута **my-attribute**, т.е. из верблюжьей нотации в шашлычную. В этом можно убедиться, открыв инструменты разработчика в браузере.

```html
<my-component>
    #shadow-root (closed)
        <div my-attribute="Мой атрибут">Атрибут с дефисом</div>
</my-component>
```

Также создать атрибут с дефисом можно, если имя свойства изначально записать с дефисом, как в атрибуте, и поместить в одинарные или двойные кавычки.

Например,

```javascript_run_edit_[my-component.js]
ODA({
    is: 'my-component',
    template: `
        <div ~props="attr">Атрибут с дефисом</div>
    `,
    attr: {
        'my-attribute': 'Мой атрибут'
    }
});
```

В данный пример аналогичен предыдущему, только имя свойства сразу записано в шашлычной нотации и помещено в кавычки.

Значения атрибутов, устанавливаемых директивой **~props**, имеют приоритет над значениями атрибутов непосредственно указанных в теге HTML-элемента.

Например,

```javascript_run_edit_[my-component.js]
ODA({
    is: 'my-component',
    template: `
        <input ~props="attr" value="Текст из атрибута">
    `,
    attr: {
        value: 'Текст из директивы'
    }
});
```

В данном примере в элементе **input** атрибут **value** явно указан в теге. Однако, как видно по результату выполнения примера, его значение было переопределено директивой.

Значения атрибутов, задаваемые операцией биндинга, имеют приоритет над значениями атрибутов, устанавливаемых директивой **~props**.

Например,

```javascript_run_edit_[my-component.js]
ODA({
    is: 'my-component',
    template: `
        <input ~props="attr" :value="'Текст из операции биндинга'">
    `,
    attr: {
        value: 'Текст из директивы'
    }
});
```

В данном примере в элементе **input** использована операции биндинга для присвоения значения атрибуту **value**. Как видно по результату выполнения примера, значение устанавливаемое директивой было проигнорировано.

Директиву **~props** можно использовать совместно с директивой **~for**. В этом случае объекты с атрибутами для создаваемых HTML-элементов должны быть объединены в один массив.

Например,

```javascript_run_edit_[my-component.js]
ODA({
    is: 'my-component',
    template: `
        <input ~for="attr" ~props="$for.item">
    `,
    attr: [
        {type: 'text', placeholder: 'Введите значение'},
        {type: 'checkbox', checked: true },
        {type: 'range', max: 100, value: 25 },
        {type: 'button', value: 'Кнопка', style: 'background: yellow' }
    ]
});
```

В этом примере шаблон компонента содержит HTML-элемент **input**, в котором указаны директивы **~for** и **~props**. Первая директива создает четыре элемента **input**, а вторая добавляет в каждый элемент свои собственные атрибуты, определяющие его функциональность.

Директива **~props** поддерживает механизм реактивности, т.е. при изменении связанного с ней объекта будут изменяться соответствующие атрибуты HTML-элемента. Однако, чтобы реактивность работала, необходимо каждый раз передавать директиве совершенно новый объект, отличающийся от предыдущего ссылкой.

Например,

```javascript_run_edit_[my-component.js]
ODA({
    is: 'my-component',
    template: `
        <input type="button" ~props="attr" @tap="onTap">
    `,
    attr: {
        value: 'Нажми меня',
    },
    onTap() {
        let v = this.attr.value=='Щелкни по мне' ? 'Нажми меня' : 'Щелкни по мне';
        this.attr = { value: v };
    }
});
```

В данном примере при нажатии на кнопку на ней меняется надпись, которая задается свойством **value** объекта **attr**, связанном с директивой **~props**. В обработчике нажатия для изменения значения свойства **value** создается новый объект с одноименным свойством и новым значением. Этот новый объект передается директиве через указатель **attr**. Как видно из примера, изменение указателя на объект заставляет срабатывать механизм реактивности и менять надпись на кнопке.

Если просто изменить значение свойства в связанном с директивой объекте, это не приведет к автоматическому выполнению директивы.

Например,

```javascript_run_edit_error_[my-component.js]
ODA({
    is: 'my-component',
    template: `
        <input type="button" ~props="attr" @tap="onTap">
    `,
    attr: {
        value: 'Нажми меня',
    },
    onTap() {
        this.attr.value = this.attr.value=='Щелкни по мне' ? 'Нажми меня' : 'Щелкни по мне';
    }
});
```

Данный пример аналогичен предыдущему, только вместо создания нового объекта меняется значение свойства **value** в прежнем объекте. Однако при нажатии на кнопку надпись на ней не меняется, значит, механизм реактивности не срабатывает.

В своей работе директива взаимодействует с DOM-объектом HTML-элемента. Для каждого добавляемого атрибута директива проверяет наличие соответствующего ему свойства в DOM-объекте. Если такое свойство существует, то директива присваивает ему новое значение, а браузер сам создает для него атрибут в HTML-элементе, если сочтет это необходимым. Если такое свойство отсутствует, то тогда директива создает атрибут в HTML-элементе с помощью метода **setAttribute** DOM-объекта.

Рассмотрим три возможных варианта взаимодействия директивы с DOM-объектом.

Пример 1,

```javascript_run_edit_[my-component.js]
ODA({
    is: 'my-component',
    template: `
        <input id="i1" placeholder="с ~props" ~props="attr" >
        <span>Имеет свойство «type»: {{'type' in $('#i1')}} — Имеет атрибут «type»: {{$('#i1').hasAttribute('type')}}</span>
        <br>
        <input id="i2" placeholder="без ~props">
        <span>Имеет свойство «type»: {{'type' in $('#i2')}} — Имеет атрибут «type»: {{$('#i2').hasAttribute('type')}}</span>
    `,
    attr: {
        type: 'text'
    }
});
```

В данном примере директива создает атрибут **type** в элементе **input**. Для контроля информация о наличии одноименного свойства и атрибута в DOM-объекте элемента выводится на экран. Для сравнения в пример включен второй элемент **input** без указанного атрибута и без директивы. Можно видеть, что свойство **type** изначально присутствует в DOM-объекте, но одноименный атрибут создан только у элемента с директивой **~props**.

Примечание — В примере используется метод **$** (см. раздел методы компонента) для получения указателя на DOM-объект элемента **input**.

Пример 2,

```javascript_run_edit_[my-component.js]
ODA({
    is: 'my-component',
    template: `
        <input id="i1" ~props="attr" >
        <span>Имеет свойство «value»: {{'value' in $('#i1')}} — Имеет атрибут «value»: {{$('#i1').hasAttribute('value')}}</span>
        <br>
        <input id="i2" placeholder="без ~props">
        <span>Имеет свойство «value»: {{'value' in $('#i2')}} — Имеет атрибут «value»: {{$('#i2').hasAttribute('value')}}</span>
    `,
    attr: {
        value: 'с ~props'
    }
});
```

Данный пример аналогичен предыдущему, только вместо атрибута **type** директива пытается создать атрибут **value**. Можно видеть, что свойство **value** изначально присутствует в DOM-объекте. В элементе **input** оно предназначено для временного хранения значений введенных пользователем, поэтому браузер не создает одноименный атрибут, хотя и использует значение свойства при отображении текста в элементе.

Пример 3,

```javascript_run_edit_[my-component.js]
ODA({
    is: 'my-component',
    template: `
        <input id="i1" placeholder="с ~props" ~props="attr" >
        <span>Имеет свойство «nick»: {{'nick' in $('#i1')}} — Имеет атрибут «nick»: {{$('#i1').hasAttribute('nick')}}</span>
        <br>
        <input id="i2" placeholder="без ~props">
        <span>Имеет свойство «nick»: {{'nick' in $('#i2')}} — Имеет атрибут «nick»: {{$('#i2').hasAttribute('nick')}}</span>
    `,
    attr: {
        nick: 'Строка ввода'
    }
});
```

Данный пример аналогичен предыдущему, только вместо атрибута **value** директива создает атрибут **nick**. Можно видеть, что свойство **nick** изначально отсутствует в DOM-объекте, но директива всё равно создает одноименный атрибут.

```warning_md
Внимательно выбирайте имена атрибутов создаваемых директивой **~props**. Директива не отличает свойства DOM-объекта, соответствующие атрибутам элемента, от других его свойств и может изменить их значение. Это может неожиданным образом повлиять на отображение HTML-элемента.
```

Например,

```javascript_run_edit_error_[my-component.js]
ODA({
    is: 'my-component',
    template: `
        <div ~props="attr">Исходный текст</div>
    `,
    attr: {
        innerText: 'Текст из директивы ~props'
    }
});
```

В данном примере директива пытается создать атрибут **inner-text** в элементе **div**, но поскольку DOM-объект содержит свойство **innerText**, вместо создания атрибута меняется содержимое текстового узла элемента.

<div style="position:relative;padding-bottom:48%; margin:10px">
    <iframe src="https://www.youtube.com/embed/JU-T3ZRUhqM?start=0" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen
    	style="position:absolute;width:100%;height:100%;"></iframe>
</div>
