Директива **~props** используется для динамического связывания свойств компонента с атрибутами HTML-элемента, в котором эта директива указана.

Связываемые свойства должны быть сгруппированы в одном объекте, который указывается как значение директивы **~props**. Директива создает в HTML-элементе из каждого свойства одноименный атрибут. Значение свойства становится значением этого атрибута.

Например,

```javascript_run_edit_[my-component.js]
ODA({
    is: 'my-component',
    template: `
        <input ~props="attr">
    `,
    attr: {
        type: 'range',
        min: 0,
        max: 100,
        step: 50
    }
});
```

В данном примере все атрибуты тега **input** заданы с помощью директивы **~props**. Если открыть инструменты разработчика в браузере, то можно убедиться, что из объекта **attr** в тег **input** перенесены все свойства.

```html
<my-component>
    #shadow-root (closed)
        <input type="range" min="0" max="100" step="50">
</my-component>
```

```info_md
Директива **~props** обеспечивает только однонаправленную связь от свойств компонента к атрибутам элемента. Изменение значений атрибутов элемента в процессе его функционирования в свойства компонента не передается.
```

Например,

```javascript_run_edit_[my-component.js]
ODA({
    is: 'my-component',
    template: `
        <input ~props="attr">
        <span>{{attr.value}}</span>
    `,
    attr: {
        type: 'range',
        min:0,
        max:100,
        step: 50,
        value: 0
    }
});
```

Данный пример аналогичен предыдущему, добавлено только свойство **value**, в котором хранится введенное пользователем значение, и вывод этого значения на экран. Подвигайте ползунок и убедитесь, что значение свойства **value** в объекте **attr** не изменяется.

С помощью директивы можно добавлять в HTML-элементы нестандартные атрибуты. Например, через такие атрибуты можно передавать параметры вложенным компонентам, или можно использовать их в CSS-селекторах.

Например,

```javascript_run_edit_[my-component.js]
ODA({
    is: 'my-component',
    imports: '@oda/button',
    template: `
        <style>
            oda-button[my-color="colorNumber_1"] {
                color: red;
            }
        </style>
        <oda-button ~props="attr">Кнопка</oda-button>
    `,
    attr: {
        myColor: 'colorNumber_1',
        icon: 'icons:android'
    }
});
```

В данном примере с помощью директивы **~props** и связанного с ней объекта **attr** настраивается вид компонента **oda-button**. Имя свойства **icon** совпадает с именем параметра компонента, в котором указывается название иконки, отображаемой на кнопке. А с помощью свойства **myColor** задается дополнительный селектор, связывающий компонент с CSS-правилом, определяющим красный цвет надписи на кнопке.

Директиву **~props** можно использовать совместно с директивой **~for**. В этом случае объекты с атрибутами для создаваемых HTML-элементов должны быть объединены в один массив.

Например,

```javascript_run_edit_[my-component.js]
ODA({
    is: 'my-component',
    template: `
        <input ~for="attr" ~props="$for.item">
    `,
    attr: [
        {type: 'text', placeholder: 'Введите значение'},
        {type: 'checkbox', checked: true },
        {type: 'range', max: 100, value: 25 },
        {type: 'button', value: 'Кнопка', style: 'background: yellow' }
    ]
});
```

В этом примере шаблон компонента содержит HTML-элемент **input**, в котором указаны директивы **~for** и **~props**. Первая директива создает четыре элемента **input**, а вторая добавляет в каждый элемент свои собственные атрибуты, определяющие его функциональность.













В своей работе директива взаимодействует с DOM-объектом HTML-элемента. Для каждого добавляемого атрибута директива проверяет наличие соответствующего ему свойства в DOM-объекте. Если такое свойство существует, то директива присваивает ему новое значение, а браузер сам создает для него атрибут в HTML-элементе, если сочтет это необходимым. Если такое свойство отсутствует, то тогда директива создает атрибут в HTML-элементе с помощью метода **setAttribute** DOM-объекта.

Рассмотрим три возможных варианта взаимодействия директивы с DOM-объектом.

Пример 1,

```javascript_run_edit_[my-component.js]
ODA({
    is: 'my-component',
    template: `
        <input id="i1" placeholder="с ~props" ~props="attr" >
        <span>Имеет свойство type: {{'type' in $('#i1')}} — Имеет атрибут type: {{$('#i1').hasAttribute('type')}}</span>
        <br>
        <input id="i2" placeholder="без ~props">
        <span>Имеет свойство type: {{'type' in $('#i2')}} — Имеет атрибут type: {{$('#i2').hasAttribute('type')}}</span>
    `,
    attr: {
        type: 'text'
    }
});
```

В данном примере директива **~props** создает атрибут **type** в элементе **input**. Для контроля информация о наличии одноименного свойства и атрибута в DOM-объекте элемента выводится на экран. Для сравнения в пример включен второй элемент **input** без указанного атрибута и без директивы. Можно видеть, что свойство **type** изначально присутствует в DOM-объекте, но одноименный атрибут создан только у элемента с директивой **~props**.

Примечание — В примере используется метод **$** (см. раздел методы компонента) для получения указателя на DOM-объект элемента **input**.

Пример 2,

```javascript_run_edit_[my-component.js]
ODA({
    is: 'my-component',
    template: `
        <input id="i1" ~props="attr" >
        <span>Имеет свойство value: {{'value' in $('#i1')}} — Имеет атрибут value: {{$('#i1').hasAttribute('value')}}</span>
        <br>
        <input id="i2" placeholder="без ~props">
        <span>Имеет свойство value: {{'value' in $('#i2')}} — Имеет атрибут value: {{$('#i2').hasAttribute('value')}}</span>
    `,
    attr: {
        value: 'с ~props'
    }
});
```

Данный пример аналогичен предыдущему, только вместо атрибута **type** директива **~props** пытается создать атрибут **value**. Можно видеть, что свойство **value** изначально присутствует в DOM-объекте. В элементе оно предназначено для временного хранения значений введенных пользователем, поэтому браузер не создает одноименный атрибут, хотя и использует значение свойства при отображении элемента.

Пример 3,

```javascript_run_edit_[my-component.js]
ODA({
    is: 'my-component',
    template: `
        <input id="i1" placeholder="с ~props" ~props="attr" >
        <span>Имеет свойство nick: {{'nick' in $('#i1')}} — Имеет атрибут nick: {{$('#i1').hasAttribute('nick')}}</span>
        <br>
        <input id="i2" placeholder="без ~props">
        <span>Имеет свойство nick: {{'nick' in $('#i2')}} — Имеет атрибут nick: {{$('#i2').hasAttribute('nick')}}</span>
    `,
    attr: {
        nick: 'Строка ввода'
    }
});
```

Данный пример аналогичен предыдущему, только вместо атрибута **value** директива **~props** создает атрибут **nick**. Можно видеть, что свойство **nick** изначально отсутствует в DOM-объекте, но директива всё равно создает одноименный атрибут.

```warning_md
Внимательно выбирайте имена атрибутов создаваемых директивой **~props**. Директива не отличает свойства DOM-объекта, соответствующие атрибутам элемента, от других его свойств и может изменить их значение. Это может неожиданным образом повлиять на отображение HTML-элемента.
````

Например,

```javascript_run_edit_error_[my-component.js]
ODA({
    is: 'my-component',
    imports: '@oda/button',
    template: `
        <div ~props="attr">Исходный текст</div>
    `,
    attr: {
        innerText: 'Текст из директивы ~props'
    }
});
```

В данном примере директива **~props** пытается создать атрибут **inner-text** в элементе **div**, но поскольку DOM-объект элемента содержит свойство **innerText**, вместо создания атрибута меняется содержимое текстового узела элемента.





















В этом примере свойства **contentText** и **innerHTML** будут добавлены в атрибуты соответствующих элементов, но их текстовое содержимое не изменится, так как ни у **span**, ни у **button** таких атрибутов нет, хотя свойства с такими именами существуют.

<div style="position:relative;padding-bottom:48%; margin:10px">
    <iframe src="https://www.youtube.com/embed/JU-T3ZRUhqM?start=0" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen
    	style="position:absolute;width:100%;height:100%;"></iframe>
</div>
