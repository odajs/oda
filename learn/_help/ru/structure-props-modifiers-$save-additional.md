Механизм сохранения данных компонента в Web-хранилище браузера реализован на базе объекта [**window.localStorage**](https://developer.mozilla.org/ru/docs/Web/API/Window/localStorage).

```warning_md
Не рекомендуется напрямую использовать объект [**window.localStorage**](https://developer.mozilla.org/ru/docs/Web/API/Window/localStorage) для работы с Web-хранилищем. Обход механизмов фреймворка может привести к непредсказуемым результатам.
```

```info_md
ODA-компоненты содержат служебный метод **$resetSettings()**, который очищает хранилище от их сохраненных свойств. Очистка хранилища может потребоваться для возврата свойств компонента к значениям по умолчанию. Метод не имеет параметров и удаляет из хранилища данные сразу всех сохраненных свойств. Вернуть начальное значение только одному конкретному свойству не получится.
```

В данной статье этот метод используют для приведения примеров в исходное состояние.

Фреймворк сохраняет данные компонента в виде пары ключ/значение.

```info_md
ODA-компоненты имеют служебное свойство **$savePath**, которое содержит ключ хранилища для данного экземпляра компонента. Это свойство доступно только по чтению.
```

В общем случае ключ состоит из двух частей, соединенных символом прямого слеша (**/**).

В качестве первой части ключа фреймворк использует имя компонента, в котором находятся сохраняемые свойства. Вторая часть ключа берется из директивы [**~save-key**](./index.html#structure-template-jsx-directives-~save-key.md), если она присутствует в теге компонента. Если директива отсутствует или её значением является пустая строка, то вторая часть у ключа также отсутствует вместе с соединяющим части прямым слешем (**/**).

В общем случае ключ имеет вид: `имяКомпонента/значениеИз~save-key`, но может состоять только из имени компонента.

Например,

```javascript _run_edit_[test-storage.js]
ODA({
    is: 'test-storage',
    template: `
        <input ::value>
        <button @tap="clear">Очистить хранилище</button>
        <span>Ключ хранилища: {{$savePath}}</span>
    `,
    value: {
        $def: 'Пример для $save',
        $save: true
    },
    clear() {
        this.$resetSettings();
        window.location.reload(true);
    }
});
```

В данном примере свойство **$savePath** содержит строку с именем компонента **test-storage**. Именно оно и является ключом для сохранения данных. В этом можно убедиться, если посмотреть на содержимое хранилища в окне инструментов разработчика. Для этого измените в поле ввода значение, заданное по умолчанию, например на текст *«тест ключа»*. Затем откройте окно инструментов разработчика и на закладке **Application** и в разделе **Storage** в списке **Local storage** выберите сервер, с которого Вы читаете эту документацию (в нашем примере ***https://odajs.org***). Убедитесь, что в списке сохраненных значений есть запись с ключом **test-storage**. В данном примере не использовалась директива [**~save-key**](./index.html#structure-template-jsx-directives-~save-key.md), поэтому ключ состоит только из имени компонента.

![Вид записи в Web-хранилище](learn/_help/ru/_images/structure-props-modifiers-$save-additional-1.png "Вид записи в Web-хранилище")

Если в проекте применён только один экземпляр компонента, то такой сокращенный ключ, состоящий только из одного имени компонента, не будет приводить к коллизиям. Однако если в проекте используется несколько экземпляров одного и того же компонента, то в хранилище будут находиться данные только от одного из них, от того, в котором данные изменились последними. При перезагрузке страницы они попадут во все остальные экземпляры.

Например,

```javascript _run_edit_[my-component.js]_{test-storage.js}
ODA({
    is: 'my-component',
    template:`
        <test-storage></test-storage><br>
        <test-storage></test-storage>
    `
});
```

В данном примере используются два экземпляра компонента **test-storage**, объявленного в предыдущем примере. Можно видеть, что свойства **$savePath** (а следовательно и ключи) в обоих экземплярах имеют одинаковое значение. Введите в поля ввода различающиеся строки, например *«тест 1»* и *«тест 2»*. Перезагрузите страницу и убедитесь, что оба поля содержат одинаковое значение, введенное последним. Кстати, поле ввода предыдущего примера (из которого мы взяли компонент) также будет содержать это же значение.

Для привязки данных в Web-хранилище к конкретному экземпляру компонента необходимо назначить каждому экземпляру индивидуальный идентификатор и включить его в состав ключа при сохранении данных. Для этой цели используется директива [**~save-key**](./index.html#structure-template-jsx-directives-~save-key.md). Она указывается в HTML-теге компонента, а её значение становится второй частью ключа. В результате ключ у каждого экземпляра становится уникальным, и их данные не смогут влиять друг на друга.

Например,

```javascript _run_edit_[my-component.js]_{test-storage.js}
ODA({
    is: 'my-component',
    template:`
        <test-storage ~save-key="'key1'"></test-storage><br>
        <test-storage ~save-key="'key2'"></test-storage>
    `
});
```

Данный пример аналогичен предыдущему, только в теги компонента **test-storage** добавлены директивы [**~save-key**](./index.html#structure-template-jsx-directives-~save-key.md) со строковыми значениями **key1** и **key2**. Можно видеть, что эти строки стали частью ключей экземпляров компонента **test-storage/key1** и **test-storage/key2** соответственно. Введите в поля ввода различающиеся строки, например *«ключ 1»* и *«ключ 2»*. Откройте окно инструментов разработчика и убедитесь, что в хранилище есть записи с ключами **test-storage/key1** и **test-storage/key2**.

![Вид записи в Web-хранилище](learn/_help/ru/_images/structure-props-modifiers-$save-additional-2.png "Вид записи в Web-хранилище")

Если свойство с модификатором **$save** перешло текущий компонент через механизм наследования, то ключ его сохранения будет включать имя наследного компонента, а не родительского, и оно будет храниться вместе с «родными» свойствами наследника под одним ключом.

Например,

```javascript _run_edit_[new-storage.js]_{test-storage.js}
ODA({
    is: 'new-storage',
    extends: 'test-storage',
    template:`
        <br>
        <input type="range" ::value="prop">
    `,
    prop: {
        $def: 0,
        $save: true
    },
});
```

В данном примере компонент **new-storage** наследует свойство **value** из компонента **test-storage**. Кроме того, он содержит свойство **prop** связанное с ползунком. Введите что-нибудь в строку ввода (например, «тест 1»), и подвигайте ползунок (например, установите его в крайнее правое положение). Затем откройте окно инструментов разработчика и убедитесь, что свойства **value** и **prop** сохранены в одной записи с ключом **new-storage**.

![Вид записи в Web-хранилище](learn/_help/ru/_images/structure-props-modifiers-$save-additional-3.png "Вид записи в Web-хранилище")

Компонент может быть вложен в другой компонент, однако ключ хранилища всегда зависит только от имени самого компонента и от значения директивы [**~save-key**](./index.html#structure-template-jsx-directives-~save-key.md) в его теге. Охватывающие компоненты не оказывают влияния на формирование ключа.

Например,

```javascript _run_edit_[my-component.js]_{test-storage.js}

ODA({
    is: 'my-storage',
    template:`
        <test-storage ~save-key="'key3'"></test-storage>
    `
});

ODA({
    is: 'my-component',
    template:`
        <my-storage ~save-key="'key4'"></my-storage><br>
        <my-storage ~save-key="'key5'"></my-storage>
    `
});
```

В данном примере компонент **test-storage** помещен в охватывающий компонент **my-storage**, при этом в его теге указана директива [**~save-key**](./index.html#structure-template-jsx-directives-~save-key.md) со строковым значением *'key3'*. В свою очередь два экземпляра компонента **my-storage** находятся в компоненте **my-component**. В их тегах в директивах [**~save-key**](./index.html#structure-template-jsx-directives-~save-key.md) заданы строковые значения *'key4'* и *'key5'*. Можно видеть, что значения ключей, заданные в охватывающих компонентах **my-storage**, не влияют на формирования ключей, во вложенном компоненте **test-storage**. В результате оба экземпляра компонента **test-storage** имеют одинаковые ключи хранилища **test-storage/key3** и, соответственно, одинаковые значения свойств после перезагрузки страницы.

Немного изменим пример,

```javascript _run_edit_[my-component.js]_{test-storage.js}

ODA({
    is: 'my-storage',
    template:`
        <test-storage ~save-key="$savePath"></test-storage>
    `
});

ODA({
    is: 'my-component',
    template:`
        <my-storage ~save-key="'key4'"></my-storage><br>
        <my-storage ~save-key="'key5'"></my-storage>
    `
});
```

Данный пример аналогичен предыдущему, только в теге вложенного компонента **test-storage** директива [**~save-key**](./index.html#structure-template-jsx-directives-~save-key.md) имеет значение свойства **$savePath**, которое содержит ключ охватывающего компонента **my-storage**. Теперь у каждого экземпляра компонента **test-storage** ключ формируется из его имени и ключа охватывающего компонента **my-storage**. В результате экземпляры компонента **test-storage** имеют различающиеся ключи-хранилища **test-storage/my-storage/key4** и **test-storage/my-storage/key5** и, соответственно, их данные теперь хранятся раздельно.






---




Значение всех свойств компонента хранится в единой строке в JSON-формате в виде множества пар **имя_свойства:значение**.

Если в примере в поля ввода ввести значения "текст 1" и "текст 2", то сохраненная строка будет иметь вид:

**{"value1":"текст 1","value2":"текст 2"}**

```info_md
Если в процессе работы одно из свойств компонента вновь примет значение по умолчанию, то оно будет удалено из сохраненной строки.
```

Так, если в нашем примере в первой строке ввода ввести текст **Введите текст 1**, соответствующий тексту по умолчанию, то значение для свойства **value1** будет удалено из хранилища, и сохраненная строка примет вид:

**{"value2":"текст 2"}**

```info_md
Если компонент создан в режиме наследования, и сохраняемые свойства объявлены в родительском компоненте, то в первой части полного ключа будет использоваться имя дочернего компонента.
```

Пример 2

```javascript _run_edit_[my-component.js]_{my-input-component.js}
ODA({
    is: 'my-derived-component',
    extends: 'my-input-component',
    template:``
});
ODA({
    is: 'my-component',
    template:`
        <my-derived-component ~save-key="'key5'"></my-derived-component>
        <div>В хранилище: {{window.localStorage.getItem("my-derived-component.key5")}}</div>
    `
});
```

В данном примере сохраняемые свойства объявлены в компоненте **my-input-component**, но в полном ключе используется имя дочернего компонента **my-derived-component**.
