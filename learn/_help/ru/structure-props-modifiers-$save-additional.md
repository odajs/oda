Механизм сохранения данных компонента в Web-хранилище браузера реализован на базе объекта [**window.localStorage**](https://developer.mozilla.org/ru/docs/Web/API/Window/localStorage).

```warning_md
Не рекомендуется напрямую использовать объект [**window.localStorage**](https://developer.mozilla.org/ru/docs/Web/API/Window/localStorage) для работы с Web-хранилищем. Обход механизмов фреймворка может привести к непредсказуемым результатам.
```

```info_md
ODA-компоненты содержат служебный метод **$resetSettings()**, который очищает Web-хранилище от их сохраненных свойств. Очистка хранилища может потребоваться для возврата свойств компонента к значениям по умолчанию. Метод удаляет данные только из хранилища, текущие значения свойств компонента не изменяются, начальные значения они примут только после перезагрузки страницы. Метод не имеет параметров и удаляет из хранилища данные сразу всех сохраненных свойств. Вернуть начальное значение только одному конкретному свойству не получится.
```

В данной статье этот метод используется совместно с методом [**window.location.reload(true)**](https://developer.mozilla.org/en-US/docs/Web/API/Location/reload "Программная перезагрузка страницы") для приведения примеров в исходное состояние.

Фреймворк сохраняет данные компонента в виде пары ключ/значение.

```info_md
ODA-компоненты имеют служебное свойство **$savePath**, которое содержит ключ Web-хранилища для данного экземпляра компонента. Это свойство доступно только по чтению.
```

В общем случае ключ состоит из двух частей, соединенных символом прямого слеша (**/**).

В качестве первой части ключа фреймворк использует имя компонента, в котором находятся сохраняемые свойства. Вторая часть ключа берется из директивы [**~save-key**](./index.html#structure-template-jsx-directives-~save-key.md), если она присутствует в теге компонента. Если директива отсутствует или её значением является пустая строка, то вторая часть у ключа также отсутствует вместе с соединяющим части прямым слешем (**/**).

В общем случае ключ имеет вид: `имяКомпонента/значениеИз~save-key`, но может состоять только из имени компонента.

Например,

```javascript _run_edit_[test-storage.js]
ODA({
    is: 'test-storage',
    template: `
        <input ::value>
        <button @tap="clear">Очистить хранилище</button>
        <span>Ключ хранилища: {{$savePath}}</span>
    `,
    value: {
        $def: 'Пример для $save',
        $save: true
    },
    clear() {
        this.$resetSettings();
        window.location.reload(true);
    }
});
```

В данном примере свойство **$savePath** содержит строку с именем компонента **test-storage**. Именно оно и является ключом для сохранения данных. В этом можно убедиться, если посмотреть на содержимое хранилища в окне инструментов разработчика. Для этого измените в поле ввода значение, заданное по умолчанию, например на текст *«тест ключа»*. Затем откройте окно инструментов разработчика и на закладке **Application** и в разделе **Storage** в списке **Local storage** выберите сервер, с которого Вы читаете эту документацию (в нашем примере ***https://odajs.org***). Убедитесь, что в списке сохраненных значений есть запись с ключом **test-storage**. В данном примере не использовалась директива [**~save-key**](./index.html#structure-template-jsx-directives-~save-key.md), поэтому ключ состоит только из имени компонента.

![Вид записи в Web-хранилище](learn/_help/ru/_images/structure-props-modifiers-$save-additional-1.png "Вид записи в Web-хранилище")

Если в проекте применён только один экземпляр компонента, то такой сокращенный ключ, состоящий только из одного имени компонента, не будет приводить к коллизиям. Однако если в проекте используется несколько экземпляров одного и того же компонента, то в хранилище будут находиться данные только от одного из них, от того, в котором данные изменились последними. При перезагрузке страницы они попадут во все остальные экземпляры.

Например,

```javascript _run_edit_[my-component.js]_{test-storage.js}
ODA({
    is: 'my-component',
    template:`
        <test-storage></test-storage><br>
        <test-storage></test-storage>
    `
});
```

В данном примере используются два экземпляра компонента **test-storage**, объявленного в предыдущем примере. Можно видеть, что свойства **$savePath** (а следовательно и ключи) в обоих экземплярах имеют одинаковое значение. Введите в поля ввода различающиеся строки, например *«тест 1»* и *«тест 2»*. Перезагрузите страницу и убедитесь, что оба поля содержат одинаковое значение, введенное последним. Кстати, поле ввода предыдущего примера (из которого мы взяли компонент) также будет содержать это же значение.

Для привязки данных в Web-хранилище к конкретному экземпляру компонента необходимо назначить каждому экземпляру индивидуальный идентификатор и включить его в состав ключа при сохранении данных. Для этой цели используется директива [**~save-key**](./index.html#structure-template-jsx-directives-~save-key.md). Она указывается в HTML-теге компонента, а её значение становится второй частью ключа. В результате ключ у каждого экземпляра становится уникальным, и их данные не смогут влиять друг на друга.

Например,

```javascript _run_edit_[my-component.js]_{test-storage.js}
ODA({
    is: 'my-component',
    template:`
        <test-storage ~save-key="'key1'"></test-storage><br>
        <test-storage ~save-key="'key2'"></test-storage>
    `
});
```

Данный пример аналогичен предыдущему, только в теги компонента **test-storage** добавлены директивы [**~save-key**](./index.html#structure-template-jsx-directives-~save-key.md) со строковыми значениями **key1** и **key2**. Можно видеть, что эти строки стали частью ключей экземпляров компонента **test-storage/key1** и **test-storage/key2** соответственно. Введите в поля ввода различающиеся строки, например *«ключ 1»* и *«ключ 2»*. Откройте окно инструментов разработчика и убедитесь, что в хранилище есть записи с ключами **test-storage/key1** и **test-storage/key2**.

![Вид записи в Web-хранилище](learn/_help/ru/_images/structure-props-modifiers-$save-additional-2.png "Вид записи в Web-хранилище")

Если свойство с модификатором **$save** перешло текущий компонент через механизм наследования, то ключ его сохранения будет включать имя наследного компонента, а не родительского, и оно будет храниться вместе с «родными» свойствами наследника под одним ключом.

Например,

```javascript _run_edit_[new-storage.js]_{test-storage.js}
ODA({
    is: 'new-storage',
    extends: 'test-storage',
    template:`
        <br>
        <input type="range" ::value="prop">
    `,
    prop: {
        $def: 0,
        $save: true
    }
});
```

В данном примере компонент **new-storage** наследует свойство **value** из компонента **test-storage**. Кроме того, он содержит свойство **prop** связанное с ползунком. Введите что-нибудь в строку ввода (например, «тест 1»), и подвигайте ползунок (например, установите его в крайнее правое положение). Затем откройте окно инструментов разработчика и убедитесь, что свойства **value** и **prop** сохранены в одной записи с ключом **new-storage**.

![Вид записи в Web-хранилище](learn/_help/ru/_images/structure-props-modifiers-$save-additional-3.png "Вид записи в Web-хранилище")

Компонент может быть вложен в другой компонент, однако ключ хранилища всегда зависит только от имени самого компонента и от значения директивы [**~save-key**](./index.html#structure-template-jsx-directives-~save-key.md) в его теге. Охватывающие компоненты не оказывают влияния на формирование ключа.

Например,

```javascript _run_edit_[my-component.js]_{test-storage.js}

ODA({
    is: 'my-storage',
    template:`
        <test-storage ~save-key="'key3'"></test-storage>
    `
});

ODA({
    is: 'my-component',
    template:`
        <my-storage ~save-key="'key4'"></my-storage><br>
        <my-storage ~save-key="'key5'"></my-storage>
    `
});
```

В данном примере компонент **test-storage** помещен в охватывающий компонент **my-storage**, при этом в его теге указана директива [**~save-key**](./index.html#structure-template-jsx-directives-~save-key.md) со строковым значением *'key3'*. В свою очередь два экземпляра компонента **my-storage** находятся в компоненте **my-component**. В их тегах в директивах [**~save-key**](./index.html#structure-template-jsx-directives-~save-key.md) заданы строковые значения *'key4'* и *'key5'*. Можно видеть, что значения ключей, заданные в охватывающих компонентах **my-storage**, не влияют на формирования ключей, во вложенном компоненте **test-storage**. В результате оба экземпляра компонента **test-storage** имеют одинаковые ключи хранилища **test-storage/key3** и, соответственно, одинаковые значения свойств после перезагрузки страницы.

Немного изменим пример,

```javascript _run_edit_[my-component.js]_{test-storage.js}

ODA({
    is: 'my-storage',
    template:`
        <test-storage ~save-key="$savePath"></test-storage>
    `
});

ODA({
    is: 'my-component',
    template:`
        <my-storage ~save-key="'key4'"></my-storage><br>
        <my-storage ~save-key="'key5'"></my-storage>
    `
});
```

Данный пример аналогичен предыдущему, только в теге вложенного компонента **test-storage** директива [**~save-key**](./index.html#structure-template-jsx-directives-~save-key.md) имеет значение свойства **$savePath**, которое содержит ключ охватывающего компонента **my-storage**. Теперь у каждого экземпляра компонента **test-storage** ключ формируется из его имени и ключа охватывающего компонента **my-storage**. В результате экземпляры компонента **test-storage** имеют различающиеся ключи-хранилища **test-storage/my-storage/key4** и **test-storage/my-storage/key5** и, соответственно, их данные теперь хранятся раздельно.

В примере сами ключи хранилища получились «говорящими». Ключ можно прочитать так: *«Здесь хранятся свойства компонента **test-storage**, находящегося в компоненте **my-storage** с ключом-идентификатором **key4**»*.

Если в компонент вложены несколько экземпляров другого компонента, то в их директивах [**~save-key**](./index.html#structure-template-jsx-directives-~save-key.md) помимо свойства **$savePath** охватывающего компонента необходимо указать индивидуальные ключи для каждого экземпляра.

Например,

```javascript _run_edit_[my-component.js]_{test-storage.js}

ODA({
    is: 'my-storage',
    template:`
        <test-storage ~save-key="'item1'+'/'+$savePath"></test-storage><br>
        <test-storage ~save-key="'item2'+'/'+$savePath"></test-storage>
    `
});

ODA({
    is: 'my-component',
    template:`
        <my-storage ~save-key="'key4'"></my-storage><br>
        <my-storage ~save-key="'key5'"></my-storage>
    `
});
```

Данный пример аналогичен предыдущему, только компонент **my-storage** содержит уже два экземпляра компонента **test-storage**. Чтобы сделать для них уникальные ключи хранилища, в их директивы [**~save-key**](./index.html#structure-template-jsx-directives-~save-key.md) добавлена операция конкатенации индивидуальных идентификаторов 'item1' и 'item2' со свойством **$savePath**.

Как видно из примера с помощью директивы [**~save-key**](./index.html#structure-template-jsx-directives-~save-key.md) и свойства **$savePath** можно легко создать уникальные ключи для любой конфигурации компонентов.

```info_md
ODA-компоненты содержат служебный метод **$loadPropValue()**, который позволяет прочитать из Web-хранилища значение заданного свойства компонента. Метод имеет единственный параметр, в котором указывается имя считываемого свойства. Если в хранилище отсутствуют данные для указанного свойства, то метод возвращает значение **undefined**.
```

Формат команды: `$loadPropValue( имя_свойства )`.

Например,

```javascript _run_edit_[test2-storage.js]
ODA({
    is: 'test2-storage',
    template: `
        <input ::value>
        <button @tap="clear">Очистить хранилище</button>
        <span>Значение в хранилище: {{$loadPropValue('value')}}</span>
    `,
    value: {
        $def: 'Пример для $save',
        $save: true
    },
    clear() {
        this.$resetSettings();
        window.location.reload(true);
    }
});
```

В данном примере с помощью метода **$loadPropValue()** значение свойства **value** считывается непосредственно из хранилища. Введите что-нибудь в строку ввода и убедитесь, что из хранилища считывается именно это значение. Нажмите кнопку *«Очистить хранилище»*. Из хранилища будет считано значение **undefined**, т.к. все данные компонента были из него удалены.

---

```info_md
ODA-компоненты содержат служебный метод **$savePropValue()**, который сохраняет в Web-хранилище заданное значение указанного свойства компонента. Метод имеет два параметра. В первом указывается имя свойства, во втором — новое значение свойства. Метод изменяет значение свойства только в хранилище, текущее значение свойства не меняется, новое значение оно получит только после перезагрузки страницы. Если в качестве значения свойства указать **undefined** или опустить второй параметр метода, то данные указанного свойства будут удалены из хранилища, и после перезагрузки страницы свойство получит начальное значение.
```

Формат команды: `$savePropValue( имя_свойства, новое_значение )`.

Например,

```javascript _run_edit_[test3-storage.js]
ODA({
    is: 'test3-storage',
    template: `
        <input ::value>
        <button @tap="clear">Очистить хранилище</button><br>
        <span>Текущее значение: {{value}}</span>
        <button @tap="save">Сохранить в хранилище</button><br>
        <button @tap="load">Прочитать из хранилища</button><br>
        <span>Значение в хранилище: {{load()}}</span>
    `,
    value: 'Пример для $save',
    clear() {
        this.$resetSettings();
        window.location.reload(true);
    },
    save() {
        this.$savePropValue('value', this.value);
    },
    load() {
        return this.$loadPropValue('value');
    }
});
```



