С помощью директивы **~props** можно привязать к HTML-элементу обработчики событий. Для этого связанный с ней объект должен содержать свойство, имя которого совпадает с названием обрабатываемого события, и значением которого является функция, объявленная с помощью ключевого слова **function**.

Например,

```javascript_run_edit_[my-component.js]
ODA({
    is: 'my-component',
    template: `
        <div ~props="attr">
            <span style='color:red'>Щелкни по мне</span>
        </div>
    `,
    attr: {
        click: function() {
            this.append(" Щёлк");
        }
    }
});
```

В данном примере с помощью директивы привязывается функция к событию **click**.

Аналогичный результат будет получен, если в объекте вместо свойства объявить метод с именем обрабатываемого события.

Например,

```javascript_run_edit_[my-component.js]
ODA({
    is: 'my-component',
    template: `
        <div ~props="attr">
            <span style='color:red'>Щелкни по мне</span>
        </div>
    `,
    attr: {
        click() {
            this.append(" Щёлк");
        }
    }
});
```

Данный пример аналогичен предыдущему, за исключением того, что свойство **click** было заменено на одноименный метод.

В качестве имен обработчиков можно использовать псевдонимы событий, определенные во фреймвоке.

Например,

```javascript_run_edit_[my-component.js]
ODA({
    is: 'my-component',
    template: `
        <div ~props="attr">
            <span style='color:red'>Щелкни по мне</span>
        </div>
    `,
    attr: {
        tap() {
            this.append(" Щёлк");
        }
    }
});
```

Данный пример аналогичен предыдущему, за исключением того, что имя обработчика было изменено с **click** на **tap**.

Обработчику автоматически передается указатель на объект события. Для доступа к нему необходимо объявить обработчик с одним аргументом.

Например,

```javascript_run_edit_[my-component.js]
ODA({
    is: 'my-component',
    template: `
        <div ~props="attr">
            <span style='color:red'>Щелкни по мне</span>
        </div>
    `,
    attr: {
        click(event) {
            this.append(" " + event.target.localName);
        }
    }
});
```

В данном примере функция-обработчик получает через параметр **event** объект события и извлекает из него имя элемента-источника события.

Если у HTML-элемента заданы два обработчика одного и того же события, один с помощью директивы **~props**, а другой в разметке элемента в соответствующем атрибуте, то при наступлении события они будут вызваны оба.

Например,

```javascript_run_edit_[my-component.js]
ODA({
    is: 'my-component',
    template: `
        <div ~props="attr" onclick="this.append(' Клац')">
            <span style='color:red'>Щелкни по мне</span>
        </div>
    `,
    attr: {
        click() {
            this.append(" Щёлк");
        }
    }
});
```

В данном примере у элемента **div** заданы два обработчика события **click**. Один задан с помощью директивы, а другой в атрибуте **onclick**. Как видно по результатам выполнения примера они вызываются оба.

```info_md
Указатель **this** внутри обработчика событий, привязанного к HTML-элементу с помощью директивы **~props**, указывает на этот элемент. Получить доступ к свойствам компонента из обработчика не получится.
```

Например,

```javascript_run_edit_[my-component.js]
ODA({
    is: 'my-component',
    template: `
        <div ~props="attr">
            <span style='color:red'>Щелкни по мне</span>
        </div>
    `,
    attr: {
        click() {
            this.append(' ' + this.localName);
        }
    }
});
```

В данном примере обработчик привязан к элементу **div** с помощью директивы и объекта **attr**. По выводимому на экран сообщению можно видеть, что указатель **this** указывает на элемент **div**.

Отдельно рассмотрим возможность использования стрелочной функции в качестве обработчика событий.

Если стрелочная функция объявлена в объекте, непосредственно привязанном к директиве **~props**, то указатель **this** будет иметь значение **undefined**.

Например,

```javascript_run_edit_[my-component.js]
ODA({
    is: 'my-component',
    template: `
        <div ~props="attr">
            <span style='color:red'>Щелкни по мне</span>
        </div>
    `,
    attr: {
        click: ()=> {
            console.log( this );
        }
    }
});
```

В данном примере в качестве обработчика события **click** используется стрелочная функция, выводящая в консоль браузера значение указателя **this**. Откроите консоль и убедитесь, что указатель имеет значение **undefined**.

Если стрелочная функция расположена в объекте, который объявлен в теле геттера, и передается директиве **~props** через вызов геттера, то указатель **this** будет указывать на объект компонента.

Например,

```javascript_run_edit_[my-component.js]
ODA({
    is: 'my-component',
    template: `
        <div ~props="attr">
            <span style='color:red'>Щелкни по мне</span>
        </div>
    `,
    message: ' Это ссылка на компонент',
    get attr() {
        return {
            click: ()=> {
                this.$('div').append(this.message);
            }
        }
    }
});
```

В данном примере объект с обработчиком события **click** объявлен внутри геттера **attr**, который передает этот объект директиве **~props**. Как видно по результатам выполнения примера указатель **this** внутри обработчика ссылается на сам компонент.

Примечание — В примере используется метод **$** (см. раздел методы компонента) для получения указателя на DOM-объект элемента **input**.

Аналогично **this** указывает на объект компонента, если объект со стрелочной функцией объявлен в теле метода, и передается директиве **~props** через его вызов.

Например,

```javascript_run_edit_[my-component.js]
ODA({
    is: 'my-component',
    template: `
        <div ~props="attr()">
            <span style='color:red'>Щелкни по мне</span>
        </div>
    `,
    message: ' Это ссылка на компонент',
    attr() {
        return {
            click: ()=> {
                this.$('div').append(this.message);
            }
        }
    }
});
```

Данный пример аналогичен предыдущему, за исключением того, что геттер **attr** заменен на одноименный метод.

