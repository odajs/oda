Чтобы у свойства, добавленного с помощью функции **ROCKS**, появилась дополнительная функциональность, необходимо при объявлении свойства указать соответствующие модификаторы. При этом формат объявления свойства принимает вид:

```javascript_md
свойство: {
      **$**модификатор_1: значениеМодификатора_1,
      **$**модификатор_2: значениеМодификатора_2,
      ………
}
```

Например,

```javascript_hideGutter
greeting: {
    $def: "Hello word",
    $type: String
}
```

В данном примере определено свойство **greeting**. С помощью модификаторов **$def** и **$type** у него заданы начальное значение **"Hello word"** и тип **String**.

Создаваемый класс может содержать большое количество свойств с одними и теми же модификаторами. В этом случае можно объединить свойства в группу, указав модификатор в качестве имени группы. Такой подход сокращает объем кода и делает его более наглядным. Синтаксис объявления такой группы имеет вид:

```javascript_md
**$**модификатор_1: {
      свойство_1: {
            **$**модификатор_2: значениеМодификатора_2,
            **$**модификатор_3: значениеМодификатора_3,
            ………
      },
      свойство_2: {
            **$**модификатор_4: значениеМодификатора_4,
            **$**модификатор_5: значениеМодификатора_5,
            ………
      },
      ………
}
```

Например,

```javascript_hideGutter
$readOnly: {
    prop1: "Я доступен только по чтению",
    prop2: "Меня нельзя изменить"
}
```

В данном примере определены два свойства **prop1** и **prop2** с общим модификатором **$readOnly**.

```warning_md
Обратите внимание, что для группировки можно использовать только модификаторы логического типа. При этом для всех объединенных в группу свойств модификатор будет иметь значение **«true»**.
```

Группирующие модификаторы можно вкладывать друг в друга:

```javascript_md
**$**модификатор_1: {
      **$**модификатор_2: {
            свойство_1: {
                  **$**модификатор_4: значениеМодификатора_4,
                  ………
            },
            свойство_2: {
                  **$**модификатор_5: значениеМодификатора_5,
                  ………
            },
            ………
      },
      **$**модификатор_3: {
            свойство_3: {
                  **$**модификатор_6: значениеМодификатора_6,
                  ………
            },
            свойство_4: {
                  **$**модификатор_7: значениеМодификатора_7,
                  ………
            },
            ………
      },
      ………
}
```

Например,

```javascript_hideGutter
$final: {
    $freeze: {
        prop1: "У меня нет реактивности",
        prop2: "У меня отключена реактивность"
    },
    $readOnly: {
        prop3: "Я доступен только по чтению",
        prop4: "Меня нельзя изменить"
    }
}
```

В данном примере в группе с общим модификатором **$final** объявлены четыре свойства, которые запрещено переопределять в наследниках. Свойства **prop1** и **prop2** дополнительно объединены в подгруппу с модификатором **$freeze**, отключающим у них реактивность. А свойства **prop3** и **prop4** объединены в подгруппу с модификатором **$readOnly**, и поэтому доступны только по чтению.

Группирующий модификатор имеет приоритет над одноименным модификатором, объявленным внутри свойства. Т.е. независимо от значения, присвоенного модификатору внутри свойства, он всегда будет иметь значение **true**.

Например,

```html run_edit_h=40_
<!--script type="module" src="https://cdn.jsdelivr.net/gh/odajs/oda/rocks.js"></script-->
<script type="module" src="./rocks.js"></script>
<button id='button'></button>
<span id='span'></span>
<script type="module">
    class myClass extends ROCKS({
        $readOnly: {
            counter: {
                $def: 0,
                $readOnly: false
            }
        }
    }) {
        constructor() {
            super();
        }
    }

    let myObject = new myClass();
    let button = document.getElementById("button");
    let span = document.getElementById("span");
    button.innerText = "Счетчик: " + myObject.counter;

    button.onclick = function() {
        try {
            ++myObject.counter;
            button.innerText = "Счетчик: " + myObject.counter;
        } catch(e) {
            span.innerText = `Ошибка: ${e.name} -- Описание: ${e.message}`;
        }
    }
</script>
```

В данном примере свойство **counter** имеет модификатор **$readOnly** со значением **false**, который отключает защиту от записи. Также оно находится внутри одноименного группирующего модификатора, который наоборот включает защиту от записи. Т.к. группирующий модификатор имеет приоритет над внутренним, то фреймворк запрещает изменение значения свойства. Нажмите кнопку и убедитесь, что при попытке инкремента свойства сработает ловушка исключений в инструкции **try…catch**, код которой выведет сообщение об ошибке «Ошибка: Error -- Описание: Read only!!! counter».

```warning_md
Если шаблон содержит одноименные геттер и сеттер, то набор модификаторов у них должен быть одинаковым. В противном случае функция **ROCKS** не сможет создать прототип класса.
```

Например,

```html run_edit_error_h=40_
<!--script type="module" src="https://cdn.jsdelivr.net/gh/odajs/oda/rocks.js"></script-->
<script type="module" src="./rocks.js"></script>
<button id='button'>Создать класс</button>
<span id='span'></span>
<script type="module">
    let button = document.getElementById("button");
    let span = document.getElementById("span");
    button.onclick = function() {
        try {
            let myClass = class extends ROCKS({
                _counter: 0,
                get counter() {
                    return this._counter;
                },
                $public: {
                    set counter(val) {
                        this._counter = val;
                    }
                }
            }) {
                constructor() {
                    super();
                }
            }
            span.innerText = "Класс создан";
        } catch(e) {
            span.innerText = "Создать класс не удалось";
        }
    }
</script>
```

В данном примере при нажатии на кнопку должен создаться класс с расширенной функциональностью. В шаблоне класса объявлены геттер и сеттер с одним и тем же именем **counter**. Сеттер имеет модификатор **$public**, а у геттера его нет. В результате функция **ROCKS** не может создать прототип класса и генерирует исключение. Инструкция **try…catch** перехватывает исключение и выводит на экран сообщение «Создать класс не удалось».

Функция **ROCKS** поддерживает следующие модификаторы:

| Имя модификатора | *  | Назначение |
| :--------------- |:--:| :--------- |
| $def         | | Начальное значение свойства |
| $type        | | Тип свойства |
| $freeze      | | Отключает реактивность у свойства |
| $readOnly    | | Указывает, что свойство является константой и его первоначальное значение изменять нельзя |
| $public      | | Во фреймворке ROCKS делает свойство перечисляемым. Во фреймворке ODA указывает, что свойство необходимо отображать в инспекторе свойств компонента |
| $pdp | | Во фреймворке ROCKS делает свойство перечисляемым. Во фреймворке ODA делает свойство компонента-владельца доступным во вложенных компонентах |
| $final       | | Во фреймворке ROCKS устанавливает у свойства дескриптор **configurable** в значение **false**. Во фреймворке ODA указывает, что свойство нельзя переопределять в наследниках |
| $description | * | Краткое описание свойства. Используется как всплывающая подсказка в инспекторе свойств компонента. Также используется для автоматической генерации раздела описания свойств в документации на компонент |
| $save        | * | Указывает на необходимость сохранения текущего значения свойства и его восстановления в следующем сеансе работы |
| $label    | * | Надпись (метка), которая будет отображаться в инспекторе свойств компонента вместо имени свойства |
| $group | * | Имя группы, в которой будет отображаться свойство в инспекторе свойств компонента |
| $list     | * | Перечень возможных значений свойства, появляющийся в выпадающем списке в инспекторе свойств компонента. Если не указан модификатор **$multiSelect**, то из списка можно выбрать только одно значение. Если указан, то в списке можно выделить и выбрать несколько значений. |
| $multiSelect | * | Используется совместно с модификатором **$list**. Позволяет выделить в списке несколько значений |
| $attr | * | Определяет будет ли имя свойства и его значение продублированы в качестве одноименного атрибута HTML-элемента самого компонента |
| $editor | * | Путь к компоненту, который является редактором значения свойства в инспекторе свойств компонента |
| $hidden | * | Запрещает отображать свойство в инспекторе свойств компонента |

```faq_md_hideicon
Примечание – Дополнительная функциональность свойств, добавляемая модификаторами, помеченными знаком «*****» (звездочка), доступна только при применении фреймворка **ROCKS** в составе фреймворка **ODA**.
```

Обратите внимание, что имена модификаторов начинаются с символа **$** (символ доллара). Это облегчает чтение кода, т.к. позволяет визуально отделить модификаторы от вложенных свойств.
