HTML-шаблон компонента описывается в атрибуте **template** прототипа в соответствии со [стандартом языка HTML](https://html.spec.whatwg.org/multipage/).

По своей структуре шаблон компонента является шаблонным литералом, заключенным в обратные кавычки (\` \`). Обратные кавычки позволяют использовать в теле шаблона нативное оформление кода HTML, такое как многострочный текст и символы двойных и одинарных кавычек.

Например,

```javascript_run_edit_[my-component.js]
ODA({
    is: 'my-component',
    template: `
        <strong>Hello, template!</strong>
    `
});
```

В шаблоне можно использовать все синтаксические конструкции JSX и ODA-framework.

Фреймворк позволяет напрямую вносить изменения в шаблон, не обращаясь к DOM-модели компонента. Для этого предусмотрены специальные синтаксические конструкции, позволяющие вставлять непосредственно в шаблон любые выражения на языке JavaScript, в том числе содержащие свойства и методы компонента. При каждом рендеринге компонента фреймворк сам определяет необходимость вычисления этих выражений, позволяя разработчику легко и просто создавать динамичные HTML-страницы.

Например,

```javascript_run_edit_[my-component.js]
ODA({
    is: 'my-component',
    template: `
        <strong>{{greeting()}}</strong>
    `,
    greeting() {
        return 'Hello, template!';
    }
});
```

В данном примере приветственное сообщение формируется методом **greeting**, вызов которого находится непосредственно в шаблоне.

Из примера видно, что в шаблоне к свойствам и методам компонента можно обращаться без использования указателя **this**, так как контент в этом случае рассматривается по умолчанию относительно самого компонента. Такой подход позволяет сделать код JavaScript-выражений более компактным и наглядным.

В целом обращение к свойствам и методам с использованием указателя **this** и без него является идентичным. Различия возникают только при попытке чтения несуществующего свойства.

Если JavaScript-выражение в HTML-шаблоне содержит обращение к несуществующему свойству компонента и при этом не используется указатель **this**, то при каждом рендеринге компонента в консоль браузера будет выводиться сообщение об отсутствии свойства. Если обращение к несуществующему свойству осуществляется с использованием указателя **this**, то сообщение о его отсутствии выводиться не будет.

Например,

```javascript _run_edit_[my-component.js]
ODA({
    is: 'error-component',
    template: `
        <span>Компонент с ошибкой.</div>
        <span>{{absent}}</span>
    `
});

ODA({
    is: 'my-component',
    template: `
        <button @tap="onTap">{{text}}</button>
        <error-component ~if="show"></error-component>
    `,
    show: false,
    text: 'Показать',
    onTap() {
        this.show = !this.show;
        this.text = this.text=='Показать' ? 'Скрыть': 'Показать';
    }
});
```

В данном примере при нажатии на кнопку в DOM-объект компонента **my-component** встраивается компонент **error-component**, в HTML-шаблоне которого в интерполяционной подстановке используется обращение к несуществующему свойству **absent**. Сразу после встраивания выполняется рендеринг страницы, в процессе которого в консоль браузера выдается сообщение:

![Консоль браузера](learn/_help/ru/_images/structure-template-jsx-html-1.png "Консоль браузера")

Еще пример,

```javascript _run_edit_[my-component.js]
ODA({
    is: 'error-component',
    template: `
        <span>Компонент с ошибкой.</div>
        <span>{{this.absent}}</span>
    `
});

ODA({
    is: 'my-component',
    template: `
        <button @tap="onTap">{{text}}</button>
        <error-component ~if="show"></error-component>
    `,
    show: false,
    text: 'Показать',
    onTap() {
        this.show = !this.show;
        this.text = this.text=='Показать' ? 'Скрыть': 'Показать';
    }
});
```

В данном примере, в отличие от предыдущего, в интерполяционной подстановке используется полное имя несуществующего свойства **this.absent**. Благодаря наличию указателя **this** в имени свойства, сообщение о его отсутствии в консоль браузера не выводится.

При вызове отсутствующих методов компонента, независимо от наличия указателя **this** в имени метода, при каждом рендеринге компонента в консоль браузера будет выводиться сообщение, что метод не объявлен.

