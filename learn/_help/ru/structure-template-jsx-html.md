HTML-шаблон компонента описывается в атрибуте **template** прототипа в соответствии со [стандартом языка HTML](https://html.spec.whatwg.org/multipage/).

По своей структуре шаблон компонента является шаблонным литералом, заключенным в обратные кавычки (\` \`). Обратные кавычки позволяют использовать в теле шаблона нативное оформление кода HTML, такое как многострочный текст и символы двойных и одинарных кавычек.

Например,

```javascript_run_edit_[my-component.js]
ODA({
    is: 'my-component',
    template: `
        <strong>Hello, template!</strong>
    `
});
```

В шаблоне можно использовать все синтаксические конструкции JSX и ODA-framework.

Фреймворк позволяет напрямую вносить изменения в шаблон, не обращаясь к DOM-модели компонента. Для этого предусмотрены специальные синтаксические конструкции, позволяющие вставлять непосредственно в шаблон любые выражения на языке JavaScript, в том числе содержащие свойства и методы компонента. При каждом рендеринге компонента фреймворк сам определяет необходимость вычисления этих выражений, позволяя разработчику легко и просто создавать динамичные HTML-страницы.

Например,

```javascript_run_edit_[my-component.js]
ODA({
    is: 'my-component',
    template: `
        <strong>{{greeting()}}</strong>
    `,
    greeting() {
        return 'Hello, template!';
    }
});
```

В данном примере приветственное сообщение формируется методом **greeting**, вызов которого находится непосредственно в шаблоне.

Из примера видно, что в шаблоне к свойствам и методам компонента можно обращаться без использования указателя **this**, так как контент в этом случае рассматривается по умолчанию относительно самого компонента. Такой подход позволяет сделать код JavaScript-выражений более компактным и наглядным.

```warning_md
В текущей версии фреймворка, если JavaScript-выражение в HTML-шаблоне содержит обращение к несуществующему свойству или методу компонента и при этом не используется указатель **this**, то компонент будет создан, но при каждом рендеринге компонента будет генерироваться исключение с сообщением об обращении к несуществующему свойству.
```

Например,

```javascript _run_edit_[my-component.js]
ODA({
    is: 'error-component',
    template: `
        <span>Компонент с ошибкой.</div>
        <span>{{absent}}</span>
    `
});

ODA({
    is: 'my-component',
    template: `
        <button @tap="onTap">{{text}}</button>
        <error-component ~if="show"></error-component>
    `,
    show: false,
    text: 'Показать',
    onTap() {
        this.show = !this.show;
        this.text = this.text=='Показать' ? 'Скрыть': 'Показать';
    }
});
```

В данном примере при нажатии на кнопку в DOM-объект компонента **my-component** встраивается **error-component**, в HTML-шаблоне которого в подстановке используется обращение к несуществующему свойству **absent**. Сразу после встраивания выполняется рендеринг страницы, в процессе которого выдается исключение:

![Консоль браузера](learn/_help/ru/_images/structure-template-jsx-html-1.png "Консоль браузера")

Если в подстановке обращение к несуществующему свойству осуществляется с использованием указателя **this**, то исключение не генерируется.

Например,

```javascript _run_edit_[my-component.js]
ODA({
    is: 'error-component',
    template: `
        <span>Компонент с ошибкой.</div>
        <span>{{this.absent}}</span>
    `
});

ODA({
    is: 'my-component',
    template: `
        <button @tap="onTap">{{text}}</button>
        <error-component ~if="show"></error-component>
    `,
    show: false,
    text: 'Показать',
    onTap() {
        this.show = !this.show;
        this.text = this.text=='Показать' ? 'Скрыть': 'Показать';
    }
});
```

В данном примере, в отличие от предыдущего, в подстановке используется полное имя несуществующего свойства **this.absent**. Благодаря наличию указателя **this** в имени свойства, исключение не вырабатывается.

