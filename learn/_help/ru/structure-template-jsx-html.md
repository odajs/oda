HTML-шаблон компонента описывается в атрибуте **template** прототипа в соответствии со [стандартом языка HTML](https://html.spec.whatwg.org/multipage/).

По своей структуре шаблон компонента является шаблонным литералом, заключенным в обратные кавычки (\` \`). Обратные кавычки позволяют использовать в теле шаблона нативное оформление кода HTML, такое как многострочный текст и символы двойных и одинарных кавычек.

Например,

```javascript_run_edit_[my-component.js]
ODA({
    is: 'my-component',
    template: `
        <div>Hello, template!</div>
    `
});
```

В HTML-шаблоне можно применять нативные интерполяционные подстановки языка JavaScript — фигурные скобки со знаком доллара:

```text hideGutter_md
**${** *JS-выражение* **}**
```

В такой подстановке можно использовать все возможности языка JavaScript, но свойства и методы компонента в них будут не доступны, так как выражение в фигурных скобках будет выполняться интерпретатором языка JavaScript до создания компонента.

Например,

```javascript _run_edit_error_[my-component.js]
ODA({
    is: 'my-component',
    template: `
        <div>Указатель на компонент: ${this}</div>
    `
});
```

Как видно из примера, в момент вычисления интерполяционной подстановки **${}** указатель **this** не определён, т.к. компонент еще не создан.

Применять в шаблоне выражения, содержащие свойства и методы компонента, можно только в специальных синтаксических конструкциях, о которых будет рассказано в следующих статьях. В них выражения вычисляются при каждом рендеринге компонента, обеспечивая динамичность его отображения.

Например,

```javascript_run_edit_[my-component.js]
ODA({
    is: 'my-component',
    template: `
        <div>{{greeting()}}</div>
    `,
    greeting() {
        return 'Hello, template!';
    }
});
```

В данном примере приветственное сообщение формируется методом **greeting**, вызов которого находится непосредственно в шаблоне в интерполяционной подстановке **{{}}** (Mustache).

Из примера видно, что в шаблоне к свойствам и методам компонента можно обращаться без использования указателя **this**, так как контент в этом случае рассматривается по умолчанию относительно самого компонента. Такой подход позволяет сделать код JavaScript-выражений более компактным и наглядным.

В целом обращение к свойствам и методам с использованием указателя **this** и без него является идентичным. Различия возникают только при попытке чтения несуществующего свойства.

Если JavaScript-выражение в HTML-шаблоне содержит обращение к несуществующему свойству компонента и при этом не используется указатель **this**, то при каждом рендеринге компонента в консоль браузера будет выводиться сообщение об отсутствии свойства. Если обращение к несуществующему свойству осуществляется с использованием указателя **this**, то сообщение о его отсутствии выводиться не будет.

Например,

```javascript _run_edit_[my-component.js]
ODA({
    is: 'error-component',
    template: `
        <span>Компонент с ошибкой.</div>
        <span>{{absent}}</span>
    `
});

ODA({
    is: 'my-component',
    template: `
        <button @tap="onTap">{{text}}</button>
        <error-component ~if="show"></error-component>
    `,
    show: false,
    text: 'Показать',
    onTap() {
        this.show = !this.show;
        this.text = this.text=='Показать' ? 'Скрыть': 'Показать';
    }
});
```

В данном примере при нажатии на кнопку в DOM-объект компонента **my-component** встраивается компонент **error-component**, в HTML-шаблоне которого в интерполяционной подстановке используется обращение к несуществующему свойству **absent**. Сразу после встраивания выполняется рендеринг страницы, в процессе которого в консоль браузера выдается сообщение:

![Консоль браузера](learn/_help/ru/_images/structure-template-jsx-html-1.png "Консоль браузера")

Еще пример,

```javascript _run_edit_[my-component.js]
ODA({
    is: 'error-component',
    template: `
        <span>Компонент с ошибкой.</div>
        <span>{{this.absent}}</span>
    `
});

ODA({
    is: 'my-component',
    template: `
        <button @tap="onTap">{{text}}</button>
        <error-component ~if="show"></error-component>
    `,
    show: false,
    text: 'Показать',
    onTap() {
        this.show = !this.show;
        this.text = this.text=='Показать' ? 'Скрыть': 'Показать';
    }
});
```

В данном примере, в отличие от предыдущего, в интерполяционной подстановке используется полное имя несуществующего свойства **this.absent**. Благодаря наличию указателя **this** в имени свойства, сообщение о его отсутствии в консоль браузера не выводится.

При вызове отсутствующего метода компонента, независимо от наличия указателя **this** в его имени, при каждом рендеринге компонента в консоль браузера будет выводиться сообщение, что метод не объявлен.

```faq_md
Таким образом, в шаблоне к свойствам компонента лучше обращаться без использования указателя **this**. Во-первых, получается более компактный и наглядный код. Во-вторых, при отсутствии свойства у компонента в консоль выводится сообщение об ошибке, что позволяет своевременно ее обнаружить и устранить.
```

Если компонент имеет свойства или методы, имена которых совпадают с зарезервированными словами языка JavaSript, то обращаться к ним можно только используя указатель **this**.

Например,

```javascript_run_edit_[my-component.js]
ODA({
    is: 'my-component',
    template: `
        <div>Значение свойства class:<b>{{this.class}}</b></div>
    `,
    class: 'Hello, template!'
});
```

В данном примере компонент содержит свойство с именем **class**, которое является зарезервированным словом языка JavaSript.
Если в этом примере убрать указатель **this**, то он будет работать неправильно:

```javascript_run_edit_error_[my-component.js]
ODA({
    is: 'my-component',
    template: `
        <div>Значение свойства class:<b>{{class}}</b></div>
    `,
    class: 'Hello, template!'
});
```

