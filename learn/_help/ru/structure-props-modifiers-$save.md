Модификатор **$save** используется для включения механизма автоматического сохранения значения свойства в Web-хранилище браузера.

Если у свойства задать этот модификатор со значением **true**, то любое изменение этого свойства внутри компонента будет приводить к автоматическому сохранению его нового значения в Web-хранилище. При обновлении страницы или при перезапуске браузера сохраненное значение автоматически извлекается из хранилища и присваивается свойству.

Чтобы вернуть свойства компонента к значениям по умолчанию, необходимо удалить их данные из Web-хранилища. Для этого служит метод компонента **$resetSettings()**. Метод не имеет параметров и удаляет из хранилища данные сразу всех свойств компонента. Вернуть начальное значение только одному конкретному свойству не получится.

В процессе создания компонента фреймворк ищет значения свойств с модификатором **$save** в Web-хранилище. Если они там отсутствуют, то берутся начальные значения, указанные в прототипе компонента.

Для примера объявим компонент, сохраняющий в Web-хранилище значение, введенное в строку ввода:

```javascript _run_edit_[test-component1.js]
ODA({
    is: 'test-component1',
    template: `
        <input ::value>
        <button @tap="clear">Очистить</button>
    `,
    value: {
        $def: 'Пример для $save',
        $save: true
    },
    clear() {
        this.$resetSettings();
        window.location.reload(true);
    }
});
```

В компоненте введенное значение попадает в свойство **value**, имеющее модификатор **$save** со значением **true**, поэтому его текущее значение автоматически запоминается в Web-хранилище и восстанавливается после перезагрузки страницы и браузера. Очистка хранилища для восстановления значения по умолчанию осуществляется кнопкой «Очистить». Запишите что-нибудь в поле ввода и обновите страницу или перезапустите браузер. Можете убедиться, что введенные данные не теряются.

Модификатор **$save** может использоваться в качестве группирующего модификатора, поэтому с его помощью можно объявить группу свойств, значения которых необходимо сохранять. Это упрощает синтаксис, т.к. не надо указывать модификатор отдельно у каждого свойства.

Например,

```javascript _run_edit_[test-component2.js]
ODA({
    is: 'test-component2',
    template: `
        <input ::value>
        <button @tap="clear">Очистить</button>
    `,
    $save: {
        value: 'Пример для $save'
    },
    clear() {
        this.$resetSettings();
        window.location.reload(true);
    }
});
```

Этот пример аналогичен предыдущему, за исключением того, что модификатор **$save** убран из объявления свойства **value** и использован для него как группирующий. Такой подход также позволил указать начальное значение непосредственно в свойстве и убрать из его описания модификатор **$def**, что сократило объем кода и сделало его более наглядным.

В отличие от технологии куки (**cookie**), способ хранения пользовательских данных в Web-хранилище имеет ряд достоинств:

1. Объекты Web-хранилища не отправляются на сервер при каждом запросе. Поэтому в хранилище можно хранить гораздо больше данных для каждого сайта. Большинство браузеров могут сохранить минимум 2 мегабайта данных (или больше), и этот объем можно поменять в настройках.

1. Сервер не может манипулировать объектами хранилища через HTTP-заголовки. Всё делается при помощи JavaScript.

1. Web-хранилище привязано к источнику (домен/протокол/порт). Это значит, что разные протоколы или поддомены определяют разные объекты хранилища и они не могут получить доступ к данным друг друга.

```info_md
Удалить из хранилища сохраненные данные всех компонентов для текущего Web-сайта можно командой **window.localStorage.clear()**.
```

При нажатии на эту красную кнопку восстанавливаются значения по умолчанию для всех примеров на данной странице. Чтобы это увидеть, необходимо обновить страницу:

```javascript _run_edit_[my-component.js]
ODA({
    is: 'my-component',
    template:`
        <button @tap="window.localStorage.clear()" style="background:red">RESET</button>
        `
});
```

```info_md
Действие модификатора **$save** основано на механизме реактивности, т.е. при изменении значения свойства, оно автоматически записывается в Web-хранилище.
```

Следует отметить, что автосохранение массивов срабатывает только при изменении указателя на массив, а не при изменении его отдельных элементов.

Например,

```javascript _run_edit_error_[test-component3.js]
ODA({
    is: 'test-component3',
    template: `
        <input type="range" ::value="value[0]">
        <button @tap="clear">Очистить</button>
    `,
    value: {
        $def: [0],
        $save: true
    },
    clear() {
        this.$resetSettings();
        window.location.reload(true);
    }
});
```

В данном примере положение ползунка передается в элемент с индексом **0** массива **value**, который объявлен с модификатором **$save**. Переместите ползунок и перезагрузите страницу, чтобы убедиться, что данные из массива **value** не восстанавливаются, т.к. не сохраняются в хранилище.

Добавим в HTML-элемент **input** перехват события **change**, в обработчике которого будем присваивать указателю **value** новый массив с актуальным положением ползунка.

```javascript _run_edit_[test-component4.js]
ODA({
    is: 'test-component4',
    template: `
        <input type="range" ::value="value[0]" @change="value=[...value]">
        <button @tap="clear">Очистить</button>
    `,
    value: {
        $def: [0],
        $save: true
    },
    clear() {
        this.$resetSettings();
        window.location.reload(true);
    }
});
```

Можно видеть, что теперь положение ползунка сохраняется при перезагрузке страницы.

Аналогично, автосохранение объектов срабатывает только при изменении указателя на объект, а не при изменении его отдельных свойств.

Например,

```javascript _run_edit_error_[test-component5.js]
ODA({
    is: 'test-component5',
    template: `
        <input type="range" ::value="value.prop">
        <button @tap="clear">Очистить</button>
    `,
    $save: {
        value: {
            prop: 0
        }
    },
    clear() {
        this.$resetSettings();
        window.location.reload(true);
    }
});
```

В данном примере положение ползунка передается в свойство **prop** объекта **value**, который объявлен с модификатором **$save**. Переместите ползунок и перезагрузите страницу, чтобы убедиться, что данные из объекта **value** не восстанавливаются, т.к. не сохраняются в хранилище.

Добавим в HTML-элемент **input** перехват события **change**, в обработчике которого будем присваивать указателю **value** новый объект с актуальным положением ползунка.

```javascript _run_edit_[test-component6.js]
ODA({
    is: 'test-component6',
    template: `
        <input type="range" ::value="value.prop" @change="value={...value}">
        <button @tap="clear">Очистить</button>
    `,
    $save: {
        value: {
            prop: 0
        }
    },
    clear() {
        this.$resetSettings();
        window.location.reload(true);
    }
});
```

Можно видеть, что теперь положение ползунка сохраняется при перезагрузке страницы.

Объект сохраняется всегда целиком. Исключить с помощью модификатора **$save** со значением **false** отдельные его свойства из процесса сохранения невозможно.

Например,

```javascript _run_edit_[test-component7.js]
ODA({
    is: 'test-component7',
    template: `
        <input type="range" ::value="value.prop" @change="value={...value}">
        <button @tap="clear">Очистить</button>
    `,
    $save: {
        value: {
            $def: {
                prop: {
                    $def: 0,
                    $save: false
                }
            }
        }
    },
    clear() {
        this.$resetSettings();
        window.location.reload(true);
    }
});
```

Данный пример аналогичен предыдущему, за исключением того, что свойство **prop** объекта **value** объявлено с модификатором **$save**, имеющим значение **false**. Можно видеть, что ползунок по-прежнему сохраняет своё положение при перезагрузке страницы. Значит, модификатор **$save** на отдельные свойства объектов не влияет.

Объект можно сохранять только целиком. Объявление отдельного свойства объекта с модификатором **$save** не приводит к сохранению этого свойства в хранилище.

Например,

```javascript _run_edit_[test-component8.js]
ODA({
    is: 'test-component8',
    template: `
        <input type="range" ::value="value.prop">
        <button @tap="clear">Очистить</button>
    `,
    value: {
        $def: {
            prop: {
                $def: 0,
                $save: true
            }
        }
    },
    clear() {
        this.$resetSettings();
        window.location.reload(true);
    }
});
```

В данном примере положение ползунка передается в свойство **prop** объекта **value**, которое объявлено с модификатором **$save**. Переместите ползунок и перезагрузите страницу, чтобы убедиться, что данные из свойства **prop** не восстанавливаются, т.к. не сохраняются в хранилище.

```info_md
Данные компонентов разного типа всегда хранятся в независимых областях Web-хранилища, поэтому они не могут влиять на сохраненные данные друг друга и не могут удалять их.
```

Например,

```javascript _run_edit_[my-component.js]
ODA({
    is: 'test-component9',
    template: `
        <input type="range" ::value>
        <button @tap="clear">Очистить</button>
    `,
    value: {
        $def: 0,
        $save: true
    },
    clear() {
        this.$resetSettings();
        window.location.reload(true);
    }
});

ODA({
    is: 'test-component10',
    extends: 'test-component9'
});

ODA({
    is: 'my-component',
    template:`
        test-component9: <test-component9></test-component9><br>
        test-component10: <test-component10></test-component10>
        `
});
```

В данном примере из компонента **test-component9** был создан наследный компонент **test-component10**. Оба этих компонента вложены в компонент **my-component**, который с их помощью формирует на экране два ползунка. Переместите ползунки и убедитесь, что после перезагрузки страницы оба ползунка сохраняют заданное им положение. Т.к. с точки зрения фреймворка ползунки формируются компонентами разного типа, то их данные сохраняются и восстанавливаются независимо друг от друга.

Если в проекте применяется несколько экземпляров одного и того же компонента, то в хранилище будет записываться значение из того свойства, которое изменено последним, независимо от того, в каком экземпляре компонента оно находится. В этом случае при обновлении страницы сохраненное значение будет восстанавливаться для всех однотипных компонентов.

Например,

```javascript _run_edit_[my-component.js]
ODA({
    is: 'test-component11',
    template: `
        <input type="range" ::value>
        <button @tap="clear">Очистить</button>
    `,
    value: {
        $def: 0,
        $save: true
    },
    clear() {
        this.$resetSettings();
        window.location.reload(true);
    }
});

ODA({
    is: 'my-component',
    template:`
        <test-component11></test-component11><br>
        <test-component11></test-component11>
    `
});
```

В данном примере два экземпляра компонента **test-component11** формируют на экране два ползунка. Переместите ползунки и убедитесь, что после перезагрузки страницы оба ползунка принимают одинаковое положение, которое соответствует положению последнего перемещённого ползунка.

Чтобы заставить фреймворк сохранять данные разных экземпляров одного компонента независимо друг от друга, необходимо с помощью директивы [**~save-key**](./index.html#structure-template-jsx-directives-~save-key.md) указать этим экземплярам уникальные идентификаторы.

Например,

```javascript _run_edit_[my-component.js]
ODA({
    is: 'test-component11',
    template: `
        <input type="range" ::value>
        <button @tap="clear">Очистить</button>
    `,
    value: {
        $def: 0,
        $save: true
    },
    clear() {
        this.$resetSettings();
        window.location.reload(true);
    }
});

ODA({
    is: 'my-component',
    template:`
        <test-component11 ~save-key="'key1'"></test-component11><br>
        <test-component11 ~save-key="'key2'"></test-component11>
    `
});
```

Данный пример аналогичен предыдущему, только в теги обоих компонентов **test-component11** были добавлены директивы [**~save-key**](./index.html#structure-template-jsx-directives-~save-key.md) со строковыми значениями **'key1'** и **'key1'**. Теперь положение ползунков сохраняется и сбрасывается независимо друг от друга, хотя сами ползунки являются экземплярами одного и того же компонента.

```like_md
Узнать больше о работе директивы **~save-key** можно [в этой статье](./index.html#structure-template-jsx-directives-~save-key.md).
```

<div style="position:relative;padding-bottom:48%; margin:10px">
    <iframe src="https://www.youtube.com/embed/uOQBlyWafe4?start=0" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen
    	style="position:absolute;width:100%;height:100%;"></iframe>
</div>

