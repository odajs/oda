Модификатор **$save** используется для включения механизма автоматического сохранения значения свойства в Web-хранилище браузера.

Если у свойства задать этот модификатор со значением **true**, то любое изменение этого свойства внутри компонента будет приводить к автоматическому сохранению его нового значения в Web-хранилище. При обновлении страницы или при перезапуске браузера сохраненное значение автоматически извлекается из хранилища и присваивается свойству.

Чтобы вернуть свойства компонента к значениям по умолчанию, необходимо удалить их данные из Web-хранилища. Для этого служит метод компонента **$resetSettings()**. Метод не имеет параметров и удаляет из хранилища данные сразу всех свойств компонента. Вернуть начальное значение только одному конкретному свойству не получится.

В процессе создания компонента фреймворк ищет значения свойств с модификатором **$save** в Web-хранилище. Если они там отсутствуют, то берутся начальные значения, указанные в прототипе компонента.

Для примера объявим компонент, сохраняющий в Web-хранилище значение, введенное в строку ввода:

```javascript _run_edit_[test-component.js]
ODA({
    is: 'test-component',
    template: `
        <input ::value>
        <button @tap="clear">Очистить</button>
    `,
    value: {
        $def: 'Пример для $save',
        $save: true
    },
    clear() {
        this.$resetSettings();
        window.location.reload(true);
    }
});
```

В компоненте введенное значение попадает в свойство **value**, имеющее модификатор **$save** со значением **true**, поэтому его текущее значение автоматически запоминается в Web-хранилище и восстанавливается после перезагрузки страницы и браузера. Очистка хранилища для восстановления значения по умолчанию осуществляется кнопкой «Очистить». Запишите что-нибудь в поле ввода и обновите страницу или перезапустите браузер. Можете убедиться, что введенные данные не теряются.

Модификатор **$save** может использоваться в качестве группирующего модификатора, поэтому с его помощью можно объявить группу свойств, значения которых необходимо сохранять. Это упрощает синтаксис, т.к. не надо указывать модификатор отдельно у каждого свойства.

Например,

```javascript _run_edit_[test2-component.js]
ODA({
    is: 'test2-component',
    template: `
        <input ::value>
        <button @tap="clear">Очистить</button>
    `,
    $save: {
        value: 'Пример для $save'
    },
    clear() {
        this.$resetSettings();
        window.location.reload(true);
    }
});
```

Этот пример аналогичен предыдущему, за исключением того, что модификатор **$save** убран из объявления свойства **value** и использован для него как группирующий. Такой подход также позволил указать начальное значение непосредственно в свойстве и убрать из его описания модификатор **$def**, что сократило объем кода и сделало его более наглядным.

В отличие от технологии куки (**cookie**), способ хранения пользовательских данных в Web-хранилище имеет ряд достоинств:

1. Объекты Web-хранилища не отправляются на сервер при каждом запросе. Поэтому в хранилище можно хранить гораздо больше данных для каждого сайта. Большинство браузеров могут сохранить минимум 2 мегабайта данных (или больше), и этот объем можно поменять в настройках.

1. Сервер не может манипулировать объектами хранилища через HTTP-заголовки. Всё делается при помощи JavaScript.

1. Web-хранилище привязано к источнику (домен/протокол/порт). Это значит, что разные протоколы или поддомены определяют разные объекты хранилища и они не могут получить доступ к данным друг друга.

```info_md
Удалить из хранилища сохраненные данные всех компонентов для текущего Web-сайта можно командой **window.localStorage.clear()**.
```

При нажатии на эту красную кнопку восстанавливаются значения по умолчанию для всех примеров на данной странице. Чтобы это увидеть, необходимо обновить страницу:

```javascript _run_edit_[my-component.js]
ODA({
    is: 'my-component',
    template:`
        <button @tap="window.localStorage.clear()" style="background:red">RESET</button>
        `
});
```

```info_md
Данные компонентов разного типа всегда хранятся в независимых областях Web-хранилища, поэтому они не могут влиять на сохраненные данные друг друга и не могут удалять их.
```

Например,

```javascript _run_edit_[my-component.js]_{test-component.js}
ODA({
    is: 'new-component',
    extends: 'test-component'
});

ODA({
    is: 'my-component',
    template:`
        test-component: <test-component></test-component><br>
        new-component: <new-component></new-component>
        `
});
```

В данном примере из компонента **test-component** был создан наследный компонент **new-component**. Введите в их поля ввода разные данные и обновите страницу. Т.к. с точки зрения фреймворка это компоненты разного типа, то их данные сохраняются и восстанавливаются независимо друг от друга.

```info_md
Действие модификатора **$save** основано на механизме реактивности, т.е. при изменении значения свойства, оно автоматически записывается в Web-хранилище.
```

Следует отметить, что автосохранение массивов срабатывает только при изменении указателя на массив, а не при изменении его отдельных элементов.

Например,

```javascript _run_edit_error_[my-component.js]
ODA({
    is: 'test-component',
    template: `
        <input type="range" ::value="value[0]">
        <button @tap="clear">Очистить</button>
    `,
    value: {
        $def: [0],
        $save: true
    },
    clear() {
        this.$resetSettings();
        window.location.reload(true);
    }
});

ODA({
    is: 'my-component',
    template:`
        <test-component ~save-key="'key3'"></test-component>
    `
});
```

В данном примере положение ползунка передается в элемент с индексом **0** массива **value**, который объявлен с модификатором **$save**. Переместите ползунок и перезагрузите страницу, чтобы убедиться, что данные из массива **value** не восстанавливаются, т.к. не сохраняются в хранилище.

Добавим в HTML-элемент **input** перехват события **change**, в обработчике которого будем присваивать указателю **value** новый массив с актуальным положением ползунка.

```javascript _run_edit_[my-component.js]
ODA({
    is: 'test-component',
    template: `
        <input type="range" ::value="value[0]" @change="value=[...value]">
        <button @tap="clear">Очистить</button>
    `,
    value: {
        $def: [0],
        $save: true
    },
    clear() {
        this.$resetSettings();
        window.location.reload(true);
    }
});

ODA({
    is: 'my-component',
    template:`
        <test-component ~save-key="'key4'"></test-component>
    `
});
```

Можно видеть, что теперь положение ползунка сохраняется между перезагрузками страницы.

Аналогично, автосохранение объектов срабатывает только при изменении указателя на объект, а не при изменении его отдельных свойств.

Например,

```javascript _run_edit_error_[my-component.js]
ODA({
    is: 'test-component',
    template: `
        <input type="range" ::value="value.prop">
        <button @tap="clear">Очистить</button>
    `,
    value: {
        $def: {
            prop: 0
        },
        $save: true
    },
    clear() {
        this.$resetSettings();
        window.location.reload(true);
    }
});

ODA({
    is: 'my-component',
    template:`
        <test-component ~save-key="'key5'"></test-component>
    `
});
```

В данном примере положение ползунка передается в свойство **prop** объекта **value**, который объявлен с модификатором **$save**. Переместите ползунок и перезагрузите страницу, чтобы убедиться, что данные из объекта **value** не восстанавливаются, т.к. не сохраняются в хранилище.

Добавим в HTML-элемент **input** перехват события **change**, в обработчике которого будем присваивать указателю **value** новый объект с актуальным положением ползунка.

```javascript _run_edit_[my-component.js]
ODA({
    is: 'test-component',
    template: `
        <input type="range" ::value="value.prop" @change="value={...value}">
        <button @tap="clear">Очистить</button>
    `,
    value: {
        $def: {
            prop: 0
        },
        $save: true
    },
    clear() {
        this.$resetSettings();
        window.location.reload(true);
    }
});

ODA({
    is: 'my-component',
    template:`
        <test-component ~save-key="'key6'"></test-component>
    `
});
```

Можно видеть, что теперь положение ползунка сохраняется между перезагрузками страницы.

```like_md
Узнать больше о работе с Web-хранилищем можно в статье посвященной директиве [**~save-key**](./index.html#structure-template-jsx-directives-~save-key.md).
```

<div style="position:relative;padding-bottom:48%; margin:10px">
    <iframe src="https://www.youtube.com/embed/uOQBlyWafe4?start=0" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen
    	style="position:absolute;width:100%;height:100%;"></iframe>
</div>

