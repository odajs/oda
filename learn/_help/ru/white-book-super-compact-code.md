**Проблемы большого кода:**

1. Длительная разработка.
1. Высокая вероятность ошибок и сложная поддержка.
1. Низкая производительность.

**Решение:**

1. Объектно-компонентный подход.
1. Декларативное конструирование.
1. Динамическая смарт-оптимизация.

Подробнее:

**Объектно-компонентный подход**

Объектный подход основан на представлении программы в виде совокупности небольших объектов, каждый из которых является экземпляром определенного класса. Классы объектов могут образовывать иерархию наследования, позволяя наследникам повторно использовать код, заданный в родительских классах. К сожалению, в web-разработке так и не научились использовать полноценное объектное наследование, применимое к web-компонентам.

**Механизмы объектного подхода**

Механизмы объектного подхода |ANGULAR | REACT | VUE | ODAJS
--|:--:|:--:|:--:|:--:
Инкапсуляция (создание закрытых WEB Components)| -* | -* | -* | +
Наследование| -* | -* | -* | +**
Полиморфизм | - | - | - | +

\* Инкапсуляции нет. Для ее реализации, необходимо использовать сторонние библиотеки LitElement.js, wrappers и т.п.

\*\* Прямо «из коробки» поддерживается как простое, так и множественное наследование

Использование полноценного объектного подхода при создании компонентов существенно снижает требования к компетентности разработчиков, позволяя им на более низких уровнях наследования быстро разрабатывать более сложные компоненты с минимальным объемом кода, но с большей функциональностью, с меньшей вероятностью совершения ошибок и с возможностью быстрой модификации унаследованных родительских элементов.

**Декларативное конструирование**

Отличным примером, иллюстрирующим преимущества декларативного подхода над императивным, будет сравнение объема кода необходимого для выполнения одной и той же задачи, например, создание 100 однотипных элементов div с разным содержимым.

**Императивный подход**

```javascript
const items = Array(100);
for (let index = 0; index < items.length; index++) {
    items[index] = index+1;
}
items.forEach( (value, index) => {
    const div = document.createElement('div');
    div.innerText = 'Элемент[' + index + '] = ' + (value);
    this.$core.shadowRoot.append( div );
});
```

**Декларативный подход (JSX)**

```javascript
<div ~for='100'>Элемент[{{$for.index}}] = {{$for.item}}</div>
```

Разница в объеме кода налицо.

**Динамическая смарт-оптимизация процесса исполнения**

Используется уникальная смарт-технология внутреннего наблюдения за состоянием системы, которая анализирует выполнение кода во время работы приложения. Даже если программист написал неоптимальный код или даже допустил ошибку, связанную с зацикливанием изменения свойств компонента, система их исправит и исполнит код. Смарт-оптимизация была создана для кардинального снижения влияния человеческого фактора на процесс исполнения: программист может ошибаться, но это не скажется на общем состоянии системы.

Без smart-оптимизации

```javascript
ODA({
  is: 'my-component',
  template: `
    <button @tap="onTap">{{a}}</button>
  `,
  ready() {
    this.b = 1;
  },
  get a() {
    if(this._a === undefined) {
      const time = Date.now();
      while (true)
        if(Date.now() > time + 3000)
           break;

      return this.c;
    }
    else
      return this._a;
  },
  set b(v) {
    if (v % 2 === 0) {
      this._a = undefined;
      this.c = this.b * 100;
    }
  },
  c: 100,
  onTap() {
    this.b++;
  },
});
```

Со смарт-оптимизацией

```javascript
ODA({
  is: 'my-component',
  template: `
   <button @tap="onTap">{{a}}</button>
  `,
  ready() {
    this.b = 0;
  },
  get a() {
    const time = Date.now();
    while (true)
      if(Date.now() > time + 3000)
         break;
    return this.c;
  },
  set b(v) {
    if (v % 2 === 1)
      this.c = this.b * 100;
  },
  c: 100,
  onTap() {
    this.b++;
  },
});
```

Разница в объеме кода налицо.

Многократные изменения состояния системы здесь не приводят к высокой нагрузке, т.к. система не отслеживает изменения системы постоянно, а лишь при необходимости (перед рендерингом). В результате чего производительность повышается кардинально.
