При работе с директивой цикла **~for** необходимо учитывать следующие особенности:

1. Пересечение имен.

    ```info_md_hideicon
    Если в компоненте явно объявлено свойство с именем **$for** или оно создается динамически, то оно перекрывает свойство **$for**, создаваемое циклом, и параметры цикла становятся недоступными.
    ```

    Например,

    ```javascript _run_edit_error_[my-component.js]
    ODA({
        is: 'my-component',
        template: `
            <div ~for="['A','B','C']">Индекс: {{$for.index}} - ключ: {{$for.key}} - элемент: {{$for.item}} - массив: [{{$for.items}}]</div>
        `,
        $for: 0
    });
    ```

    В этом примере в компоненте явно объявлено свойство **$for**. В результате вместо параметров цикла выводится значение **undefined**.

1. Ограниченная область видимости параметров цикла.

    ```info_md_hideicon
    Область видимости параметров цикла ограничена HTML-элементом, в котором объявлена директива **~for**. На уровне компонента нет доступа к параметрам цикла.
    ```

    Например,

    ```javascript _run_edit_[my-component.js]
    ODA({
        is: 'my-component',
        template: `
            <div ~for="['A','B','C']">Проверка свойства $for у компонента: {{'$for' in this}}</div>
        `
    });
    ```

    Как видно из примера, оператор **in** не находит свойство **$for** у объекта компонента **this**, следовательно, нельзя напрямую обратиться к параметрам цикла в теле компонента.

    ```info_md_hideicon
    Т.к. область видимости объекта **$for** ограничена собственным HTML-элементом, то в шаблоне компонента можно использовать несколько независимых HTML-элементов с директивами **~for**. При этом объекты с параметрами циклов получают одинаковые имена, т.к. отсутствует перекрытие областей их определения.
    ```

    Например,

    ```javascript _run_edit_[my-component.js]
    ODA({
        is: 'my-component',
        template: `
            <div ~for="array_1">Элемент[{{$for.index}}]: {{$for.item}} -- Источник: [{{$for.items}}]</div>
            <div ~for="array_2">Элемент[{{$for.index}}]: {{$for.item}} -- Источник: [{{$for.items}}]</div>
        `,
        array_1: ['A', 'B', 'C'],
        array_2: ['D', 'E', 'F']
    });
    ```

    В этом примере в элементах **div** директивы **~for** создают объекты с одним и тем же именем **$for**. Так как HTML-элементы с директивами независимы друг от друга, конфликта имен объектов не происходит, и каждая директива обращается к элементам именно своего массива.

1. Внешний доступ к параметрам цикла.

    ```info_md_hideicon
    Если параметры цикла необходимо использовать за пределами HTML-элемента, в котором он объявлен, то их можно передать методам компонента через список параметров, или передать указатель на сам объект **$for**.
    ```

    Например,

    ```javascript _run_edit_[my-component.js]
    ODA({
        is: 'my-component',
        template: `
            <div ~for="['A','B','C']">Элемент: {{getValue($for)}}</div>
        `,
        getValue( param ) {
            return param.items[param.index];
        }
    });
    ```

    В этом примере текущее значение для директивы **~for** формируется методом **getValue**. В качестве параметра этому методу передается объект **$for**. В результате этого метод получает доступ к параметрам цикла.

    ```warning_md
    ВНИМАНИЕ!!! Не изменяйте параметры цикла в объекте **$for**. Это может привести к непредсказуемым результатам работы директивы **~for**.
    ```

1. Применение директивы к ODA-компонентам

    ```info_md_hideicon
    С помощью директивы **~for** помимо нативных HTML-элементов можно создавать последовательности компонентов. Причем шаблоны этих компонентов сами могут содержать директивы **~for**.
    ```

    Внешние и внутренние директивы генерируют объекты с параметрами цикла независимо друг от друга, поэтому их имена могут совпадать. Однако эти объекты находятся в разных областях видимости, и конфликты между параметрами внешнего и внутреннего циклов не возникают. С помощью директивы биндинга можно передавать параметры внешнего цикла внутрь компонента.

    Например,

    ```javascript _run_edit_[my-component.js]
    ODA({
        is: 'inside-component',
        template: `
            <div ~for="array">Элемент[{{$for.index}}]: {{$for.item}}</div>
        `,
        array:[]
    });

    ODA({
        is: 'my-component',
        template: `
            <inside-component ~for="object" :array='$for.item'></inside-component>
        `,
        object: {
            array_1: ['A', 'B', 'C'],
            array_2: ['D', 'E', 'F']
        }
    });
    ```

    В этом примере компонент **inside-component** имеет внешнюю и внутреннюю директивы **~for**. Внешняя директива поочередно выбирает все свойства объекта **object**, которые являются одномерными массивами. Они передаются каждой копии компонента **inside-component** из параметра **$for.item** внешнего цикла через биндинг и служат исходными данными для внутренней директивы **~for**. В примере во внешних и внутрених циклах используется параметр с одни и тем же именем **$for.item**, но это не приводит к конфликту между параметрами, поскольку они находятся в разных областях видимости.

1. Обработка неопределенных элементов массивов.

    ```info_md_hideicon
    Директива **~for** обрабатывает все элементы из источника данных, даже если эти элементы имеют неопределенное значение.
    ```

    Например,

    ```javascript _run_edit_[my-component.js]
    ODA({
        is: 'my-component',
        template: `
            <div ~for="array">Элемент[{{$for.index}}]: {{$for.item}}</div>
        `,
        array: ['A', , 'C']
    });
    ```

    В этом примере при объявлении массива **array** пропущен элемент с индексом **1**. Однако директива **~for** все равно создаст для него очередной HTML-элемент **div** и будет использовать в нем неопределенное значение **undefined** в качестве значения параметра цикла **$for.item**.

    ```info_md_hideicon
    Чтобы избежать создания HTML-элементов для неопределенных значений из источника данных можно использовать директиву **~if="$for.item"**, которая будет отфильтровывать неопределенное элементы.
    ```

    Например,

    ```javascript _run_edit_[my-component.js]
    ODA({
        is: 'my-component',
        template: `
            <div ~for="array" ~if="$for.item">Элемент[{{$for.index}}]: {{$for.item}}</div>
        `,
        array: ['A', , 'C']
    });
    ```

    В этом примере элементы **div** для неопределенных элементов массива уже отображаться не будут, так как после их создания директива **~if** удалит их из документа. Это происходит потому, что ее параметр **undefined** будет восприниматься как значение **false**, при котором данный компонент отображаться на странице уже не должен.

1. Обработка отсутствующих элементов массивов.

    ```warning_md
    Если последовательность элементов массива не является непрерывной, то директива **~for** автоматически использует вместо отсутствующих элементов последующий существующий элемент массива. Таким образом, этот элемент будет использован директивой несколько раз: за самого себя и вместо предшествующих ему отсутствующих элементов.
    ```

    Например,

    ```javascript _run_edit_[my-component.js]_h=75_
    ODA({
        is: 'my-component',
        template: `
            <div ~for="array">Элемент[{{$for.index}}]: {{$for.item}} -- Источник: [{{$for.items}}]</div>
        `,
        array: [],
        ready() {
            this.array[0] = 'A';
            this.array[3] = 'D';
        }
    });
    ```

    В этом примере, при создании элементов массива **array** в хуке **ready**, пропущены элементы с индексами **1** и **2**. Директива **~for** создает HTML-элемент **div** для элемента массива с индексом **0** и, не обнаружив очередного ожидаемого элемента с индексом **1**, ищет ближайший последующий элемент. Этим элементом является элемент с индексом **3**. И директива создает очередной объект **$for** на базе этого элемента и соответствующий ему HTML-элемент. Аналогично директива поступает с отсутствующим элементом с индексом **2**. Таким образом, элемент массива с индексом **3** был использован для построения 3-х HTML-элементов.

    ```info_md_hideicon
    Чтобы исключить создание HTML-элементов для отсутствующих элементов массива, его можно превратить в объект с помощью оператора **spread**. Тогда выражение с директивой **~for** примет вид **~for="{…имя массива}"**.
    ```

    Например,

    ```javascript _run_edit_[my-component.js]
    ODA({
        is: 'my-component',
        template: `
        <div ~for="{...array}">Элемент[{{$for.key}}]: {{$for.item}} -- Источник: {{JSON.stringify($for.items)}}</div>
        `,
        array: [],
        ready() {
            this.array[0] = 'A';
            this.array[3] = 'D';
        }
    });
    ```

    В этом примере оператор **spread** извлек из массива **array** только существующие элементы, из которых оператор **{}** создал объект из двух свойств. Индексы элементов стали ключами свойств, а значения элементов стали значениями свойств. Теперь директива **~for** создала HTML-элементы только для существующих элементов массива.

1. Целочисленный источник данных.

    ```info_md_hideicon
    Если в качестве источника данных указать положительное целое число, то директива **~for** автоматически преобразует его в массив целых чисел в диапазоне от 1 до заданного значения.
    ```

    Например,

    ```javascript _run_edit_[my-component.js]
    ODA({
        is: 'my-component',
        template: `
            <div ~for="10">Элемент[{{$for.index}}]: {{$for.item}} – источник данных: [{{$for.items}}]</div>
        `
    });
    ```

    В данном примере источником данных выступает целое число. Оно будет автоматически преобразовано в массив из 10 целых чисел в диапазоне от 1 до 10 включительно. В результате этого директива **~for** создаст 10 однотипных элементов **div**, для каждого из этих десяти чисел.

    ```info_md_hideicon
    Директива **~for** не умеет самостоятельно преобразовывать вещественные числа в целые, поэтому она не создает никаких HTML-элементов, если в качестве источника данных указано вещественное число.
    ```

    Например,

    ```javascript _run_edit_error_[my-component.js]
    ODA({
        is: 'my-component',
        template: `
            <div ~for="10.5">Элемент[{{$for.index}}]: {{$for.item}} – источник данных: [{{$for.items}}]</div>
        `
    });
    ```

    В этом примере ни одного элемента **div** создано не будет.

1. Символьный источник данных.

    ```info_md_hideicon
    При использовании строки в качестве источника данных, директива **~for** будет создавать новый HTML-элемент для каждого символа по отдельности, воспринимая их как отдельные элементы обычного массива.
    ```

    Например,

    ```javascript _run_edit_[my-component.js]
    ODA({
        is: 'my-component',
        template: `
            <div ~for="str">Элемент[{{$for.index}}]: {{$for.item}} – источник данных: [{{$for.items}}]</div>
        `,
        str: "Привет!"
    });
    ```

    В данном примере будет создано семь HTML-элементов **div** для каждого символа строки **"Привет!"**.

1. Директива **~for** поддерживает механизм реактивности, т.е. автоматически изменяет созданные ей HTML-элементы при изменении значения связанного с ней источника данных.

    Например,

    ```javascript _run_edit_[my-component.js]
    ODA({
        is: 'my-component',
        template: `
            <button @tap="tap">Изменить свойство</button>
            <div ~for="object">Свойство {{$for.key}}: {{$for.item}}</div>
        `,
        object: {
            prop1:'A', prop2:'B'
        },
        tap() {
            this.object.prop1 += 'A';
        }
    });
    ```

    В данном примере при нажатии на кнопку изменяется значение свойства **prop1** объекта **object**. Можно видеть, что новое значение сразу отображается на экране.

    Механизм реактивности отслеживает не только изменение существующих значений в источнике данных, также он отслеживает добавление новых элементов.

    Например,

    ```javascript _run_edit_[my-component.js]_h=75_
    ODA({
        is: 'my-component',
        template: `
            <button @tap="tap">Добавить свойство</button>
            <div ~for="object">Свойство {{$for.key}}: {{$for.item}}</div>
        `,
        object: {
            prop1:'A', prop2:'B'
        },
        tap() {
            this.object.prop3 = 'C';
        }
    });
    ```

    В данном примере при нажатии на кнопку в объект **object** добавляется новое свойство **prop3**. Можно видеть, что новое свойство сразу отображается на экране.

<div style="position:relative;padding-bottom:48%; margin:10px">
    <iframe src="https://www.youtube.com/embed/GoEiwg_mkb0?start=0" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen
    	style="position:absolute;width:100%;height:100%;"></iframe>
</div>

